//
// Copyright 2023 Wultra s.r.o.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.
//

package com.wultra.android.malwarelytics.reactnative

import android.app.Activity
import android.os.Handler
import android.os.Looper
import androidx.annotation.MainThread
import com.facebook.react.util.RNLog
import com.wultra.android.appprotection.AppProtection
import java.util.concurrent.Executors

/**
 * The `MalwarelyticsNativeHelper` class provides additional functionality for application using Malwarelytics from
 * the native code.
 */
class MalwarelyticsNativeHelper private constructor(
    /**
     * Instance of AppProtection
     */
    internal val appProtectionService: AppProtection
) {

    companion object {
        /**
         * Shared instance of the helper class.
         */
        @JvmStatic
        val instance: MalwarelyticsNativeHelper by lazy {
            MalwarelyticsNativeHelper(AppProtection.getInstance())
        }
    }

    /**
     * Contains `true` if service is initialized.
     */
    internal val isServiceInitialized: Boolean
        get() = appProtectionService.isInitialized()

    /**
     * Contains all activities registered for protection.
     */
    private val activitiesRegisteredForProtection = mutableListOf<Activity>()

    /**
     * Register activity for protection provided by native `AppProtection`. This method is useful in case that
     * React-Application has its own activities created and used before the Malwarelytics module is initialized from
     * the JavaScript. You don't need to use this method once the module is initialized. All future activities will be
     * protected automatically.
     *
     * @param activity Activity to protect.
     */
    @MainThread
    fun registerActivityForProtection(activity: Activity) {
        if (isServiceInitialized) {
            // Service is already initialized, so try to protect activity directly.
            appProtectionService.getRaspManager().protectActivity(activity);
        } else {
            // Service is not initialized, or the initialization is pending.
            executeOnQueue {
                if (!isServiceInitialized) {
                    // Keep activity for later.
                    activitiesRegisteredForProtection.add(activity)
                } else {
                    // This is rare, but it seems that service was initialized meanwhile. To do not forget to protect
                    // this one particular activity, we have to
                    protectActivitiesRegisteredForProtection(activity)
                }
            }
        }
    }

    /**
     * Protect all application's registered activities.
     * The method can be called only from the thread assigned to the serial queue.
     * @param additionalActivity If provided, then also this additional activity will be protected.
     */
    internal fun protectActivitiesRegisteredForProtection(additionalActivity: Activity? = null) {
        checkWorkerQueue()
        val activitiesToProtect = activitiesRegisteredForProtection.toMutableList()
        additionalActivity?.let { activitiesToProtect.add(it) }
        activitiesRegisteredForProtection.clear()
        executeOnMainThread {
            if (isServiceInitialized) {
                activitiesToProtect.forEach { appProtectionService.getRaspManager().protectActivity(it) }
            }
        }
    }

    /**
     * Perform cleanup tasks when the application was restarted in development mode.
     * The method can be called only from the thread assigned to the serial queue.
     */
    internal fun onDevelopmentReset() {
        checkWorkerQueue()
        activitiesRegisteredForProtection.clear()
    }

    /**
     * Execute action on the internal serial queue. If the current thread is already the thread
     * associated to the queue, then execute action immediately.
     *
     * Note that this method doesn't handle exceptions.
     */
    internal fun executeOnQueue(action: () -> Unit) {
        if (Thread.currentThread().id == serialExecutorThread) {
            action()
        } else {
            serialExecutor.execute(action)
        }
    }

    /**
     * Execute action on main application's thread. If the current thread is already the main thread, then execute
     * action immediately.
     *
     * Note that this method doesn't handle exceptions.
     */
    internal fun executeOnMainThread(action: () -> Unit) {
        if (Looper.myLooper() == Looper.getMainLooper()) {
            action()
        } else {
            mainThreadHandler.post(action)
        }
    }

    /**
     * Execute provided closure on the serial queue. If execution fails, then the exception is consumed and reported to the console.
     * @param action Action to execute on the serial queue.
     */
    internal fun onQueue(action: (service: AppProtection) -> Unit) {
        executeOnQueue {
            try {
                action(appProtectionService)
            } catch (e: Throwable) {
                printError("Background task failed: $e")
            }
        }
    }

    /**
     * Validate whether function is called from the internal serial queue. If this is different
     * thread then
     */
    internal fun checkWorkerQueue() {
        if (Thread.currentThread().id != serialExecutorThread) {
            throw IllegalStateException("Method called on wrong thread")
        }
    }

    /**
     * Print warning to the console. The function is using [RNLog] under the hood.
     */
    internal fun printWarning(message: String) {
        if (BuildConfig.DEBUG) {
            RNLog.l("WARNING: $message")
        }
    }

    /**
     * Print error to the console. The function is using [RNLog] under the hood.
     */
    internal fun printError(message: String) {
        if (BuildConfig.DEBUG) {
            RNLog.l("ERROR: $message")
        }
    }

    /**
     * Single thread executor.
     */
    private val serialExecutor = Executors.newSingleThreadExecutor()

    /**
     * Identifier of thread used by the serial executor.
     */
    private var serialExecutorThread: Long = -1

    /**
     * Handler for executing tasks on main thread.
     */
    private val mainThreadHandler = Handler(Looper.getMainLooper())

    init {
        serialExecutor.execute {
            // Capture the thread identifier for optimized tasks execution.
            serialExecutorThread = Thread.currentThread().id
            // Release service if it's somehow already initialized.
            if (isServiceInitialized) {
                printWarning("AppProtection service is already initialized")
                appProtectionService.release()
            }
        }
    }

}
