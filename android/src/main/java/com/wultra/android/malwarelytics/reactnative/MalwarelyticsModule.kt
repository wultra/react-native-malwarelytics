//
// Copyright 2023 Wultra s.r.o.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.
//

package com.wultra.android.malwarelytics.reactnative

import android.content.pm.PackageManager
import android.graphics.Bitmap
import android.graphics.drawable.BitmapDrawable
import android.util.Base64.encodeToString
import com.facebook.react.bridge.Arguments
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.bridge.ReactContextBaseJavaModule
import com.facebook.react.bridge.ReactMethod
import com.facebook.react.bridge.Promise
import com.facebook.react.bridge.ReadableArray
import com.facebook.react.bridge.ReadableMap
import com.facebook.react.util.RNLog
import com.wultra.android.appprotection.AppProtection
import com.wultra.android.rasp.*
import java.io.ByteArrayOutputStream
import java.util.concurrent.Executor
import java.util.concurrent.Executors

class MalwarelyticsModule(reactContext: ReactApplicationContext) :
    ReactContextBaseJavaModule(reactContext) {

    enum class State {
        SHUTDOWN,
        PENDING_INIT,
        READY,
        PENDING_SHUTDOWN
    }

    enum class Event(val value: String) {
        STATE("Malwarelytics.STATE"),
        RASP("Malwarelytics.RASP"),
        AV("Malwarelytics.AV"),
    }

    private var moduleState = State.SHUTDOWN
    private var moduleInitResult: AppProtection.InitializationResult? = null

    override fun getName(): String {
        return "Malwarelytics"
    }

    override fun initialize() {
        super.initialize()
        RNLog.l("Initialize")
    }

    override fun invalidate() {
        super.invalidate()
        if (moduleState == State.READY) {
            releaseService(appProtectionService, false)
        }
    }

    // Events

    val eventHelper = EventHelper(Event.values().map { it.value }, reactContext)

    @ReactMethod
    fun getSupportedEvents(promise: Promise) {
        promise.resolve(eventHelper.supportedEvents.toJs())
    }

    @ReactMethod
    fun addListener(eventName: String) {
        eventHelper.addListener(eventName)
    }

    @ReactMethod
    fun removeListeners(count: Int) {
        eventHelper.removeListeners(count)
    }

    private fun sendEvent(event: Event, body: Any, checkState: Boolean = true) {
        onQueue {
            if (checkState && moduleState != State.READY) {
                RNLog.w(reactApplicationContext, "Cannot send event ${event.value} because module is not in READY state")
            } else {
                eventHelper.sendEvent(event.value, body)
            }
        }
    }


    // Exported methods

    @ReactMethod
    fun initialize(config: ReadableMap?, promise: Promise) {
        onQueue(promise, State.SHUTDOWN) { service ->
            if (config == null) {
                throw MissingParameterException("configuration")
            }
            changeState(State.PENDING_INIT)
            service.initializeAsync(config.toAppProtectionConfig(reactApplicationContext.applicationContext, this), object : AppProtection.InitializationObserver {
                override fun onInitialized(initializationResult: AppProtection.InitializationResult) {
                    resolveOnQueue(promise, null) {
                        changeState(State.READY)
                        moduleInitResult = initializationResult
                        service.getRaspManager().registerRaspObserver(raspObserver)
                        initializationResult.name
                    }
                }
            })
        }
    }

    @ReactMethod
    fun shutdown(clearAvUserId: Boolean, promise: Promise) {
        resolveOnQueue(promise) { service ->
            changeState(State.PENDING_SHUTDOWN)
            releaseService(service, clearAvUserId)
            changeState(State.SHUTDOWN)
        }
    }

    @ReactMethod
    fun getState(promise: Promise) {
        resolveOnQueue(promise, null) {
            Arguments.createMap()
                .put("state", moduleState.name)
                .put("result", moduleInitResult?.name)
        }
    }

    @ReactMethod
    fun setClientId(clientId: String?, promise: Promise) {
        resolveOnQueue(promise) { service ->
            service.updateClientAppDeviceId(clientId)
        }
    }

    @ReactMethod
    fun setDeviceId(deviceId: String?, promise: Promise) {
        resolveOnQueue(promise) { service ->
            service.updateClientAppDeviceId(deviceId)
        }
    }

    @ReactMethod
    fun getAvUserId(promise: Promise) {
        resolveOnQueue(promise) { service ->
            service.getAvUserId()
        }
    }

    @ReactMethod
    fun getRaspInfo(message: String?, promise: Promise) {
        resolveOnQueue(promise) { service ->
            if (message == null) {
                throw MissingParameterException("message")
            }
            val messageType = try {
                RaspMessageType.valueOf(message)
            } catch (e: Throwable) {
                throw InvalidParameterException("message", e)
            }
            getRaspInfo(service, messageType)
        }
    }
    private fun getRaspInfo(service: AppProtection, message: RaspMessageType): Any? {
        val rasp = service.getRaspManager()
        return when (message) {
            RaspMessageType.DEBUGGER -> rasp.isDebuggerAttached()
            RaspMessageType.SYSTEM_INTEGRITY -> rasp.getRootDetection().toJs()
            RaspMessageType.REPACKAGED -> rasp.isAppRepackaged().toString()
            RaspMessageType.HTTP_PROXY -> rasp.getHttpProxyDetection().toJs()
            RaspMessageType.SCREEN_SHARING -> rasp.getScreenSharingDetection().toJs()
            RaspMessageType.EMULATOR -> rasp.getEmulatorDetection().toJs()
            RaspMessageType.VPN -> rasp.isVpnEnabled()
            RaspMessageType.TAPJACKING -> rasp.getTapjackingDetection().toJs()
            RaspMessageType.ADB_STATUS -> rasp.isAdbEnabled()
            RaspMessageType.NA_SCREEN_READER -> rasp.isNotAllowedScreenReaderEnabled()
            RaspMessageType.SCREEN_LOCK -> rasp.isDeviceUsingScreenLock()
            RaspMessageType.PLAY_PROTECT -> rasp.isPlayProtectEnabled()
            RaspMessageType.TAPJACKING_APP_PRESENT -> rasp.isBadTapjackingCapableAppPresent()
            RaspMessageType.DEVELOPER_MODE -> rasp.isDeveloperOptionsEnabled()
        }
    }

    // Service

    private fun releaseService(service: AppProtection, clearAvUserId: Boolean) {
        service.getRaspManager().unregisterRaspObserver(raspObserver)
        if (clearAvUserId) {
            service.releaseAndResetAvUid()
        } else {
            service.release()
        }
        raspEventsMap.clear()
        moduleInitResult = null
    }

    // Private methods

    // Observing RASP events

    private enum class RaspMessageType {
        DEBUGGER,
        SYSTEM_INTEGRITY,
        REPACKAGED,
        HTTP_PROXY,
        SCREEN_SHARING,
        EMULATOR,
        VPN,
        TAPJACKING,
        ADB_STATUS,
        SCREEN_LOCK,
        PLAY_PROTECT,
        NA_SCREEN_READER,
        TAPJACKING_APP_PRESENT,
        DEVELOPER_MODE
    }

    private val raspObserver = object: RaspObserver {
        override fun onAdbStatusDetected(adbStatus: Boolean) {
            sendRaspEvent(RaspMessageType.ADB_STATUS, adbStatus, adbStatus)
        }

        override fun onDebuggerDetected(debuggerDetected: Boolean) {
            sendRaspEvent(RaspMessageType.DEBUGGER, debuggerDetected, debuggerDetected)
        }

        override fun onEmulatorDetected(emulatorDetection: EmulatorDetection) {
            sendRaspEvent(RaspMessageType.EMULATOR, emulatorDetection.toJs(), emulatorDetection.isEmulator)
        }

        override fun onHttpProxyDetected(httpProxyDetection: HttpProxyDetection) {
            sendRaspEvent(RaspMessageType.HTTP_PROXY, httpProxyDetection.toJs(), httpProxyDetection.isHttpProxyEnabled)
        }

        override fun onRepackagingDetected(repackagingResult: RepackagingResult) {
            sendRaspEvent(RaspMessageType.REPACKAGED, repackagingResult.toString(), repackagingResult != RepackagingResult.ORIGINAL_APP)
        }

        override fun onRootDetected(rootDetection: RootDetection) {
            sendRaspEvent(RaspMessageType.SYSTEM_INTEGRITY, rootDetection.toJs(), rootDetection.isRooted)
        }

        override fun onScreenSharingDetected(screenSharingDetected: Boolean) {
            sendRaspEvent(RaspMessageType.SCREEN_SHARING, simpleWritableMap("isScreenShared", screenSharingDetected), screenSharingDetected)
        }

        override fun onTapjackingDetected(tapjackingDetection: TapjackingDetection) {
            sendRaspEvent(RaspMessageType.TAPJACKING, tapjackingDetection.toJs(), tapjackingDetection.isTapjackingBlocked)
        }

        override fun onVpnDetected(vpnEnabled: Boolean) {
            sendRaspEvent(RaspMessageType.VPN, vpnEnabled, vpnEnabled)
        }
    }

    private fun sendRaspEvent(messageType: RaspMessageType, body: Any, important: Boolean) {
        onQueue {
            if (shouldReportEvent(messageType, body, important)) {
                val payload = Arguments.createMap()
                payload.put("type", messageType.name)
                payload.putAny("payload", body)
                sendEvent(Event.RASP, payload)
            }
        }
    }

    // RASP event filter

    private val raspEventsMap = mutableMapOf<String, String>()

    /**
     * Determine whether event type should be reported or not. When the service starts, some events
     * can be omitted when message is not important. The function also filter events when the content
     * of the message is the same as previous.
     */
    private fun shouldReportEvent(messageType: RaspMessageType, body: Any, important: Boolean): Boolean {
        val key = messageType.name
        val lastValue = raspEventsMap[key]
        val currentValue = when (body) {
            is String -> body
            is ReadableMap -> body.toHashMap().toString()
            is ReadableArray -> body.toArrayList().toString()
            is Boolean -> if (body) "true" else "false"
            else -> throw java.lang.IllegalArgumentException("Unsupported body in message")
        }
        if (lastValue == null) {
            // This is initial state, no previous event was captured
            raspEventsMap[key] = currentValue
            return important
        }
        if (currentValue != lastValue) {
            raspEventsMap[key] = currentValue
            return true
        }
        // No change since last event
        return false
    }

    // Antivirus

    @ReactMethod
    fun isAntivirusEnabled(promise: Promise) {
        resolveOnQueue(promise) { service ->
            service.isAntivirusEnabled()
        }
    }

    @ReactMethod
    fun setAntivirusLocalization(code: String?, promise: Promise) {
        resolveOnQueue(promise) { service ->
            service.getAntivirus().getSmartProtectionManager().setCustomLocalization(code)
        }
    }

    @ReactMethod
    fun getAntivirusLocalization(promise: Promise) {
        resolveOnQueue(promise) { service ->
            service.getAntivirus().getSmartProtectionManager().getCustomLocalization()
        }
    }

    @ReactMethod
    fun triggerSmartProtection(performOnlineUpdate: Boolean, promise: Promise) {
        onQueue(promise) { service ->
            triggerSmartProtectionImpl(service, performOnlineUpdate, promise)
        }
    }

    @ReactMethod
    fun isSmartProtectionTriggered(promise: Promise) {
        resolveOnQueue(promise) {
            smartProtectionRequests.isNotEmpty()
        }
    }

    private val smartProtectionRequests = mutableListOf<Promise>()
    private val smartProtectionExecutor: Executor by lazy { Executors.newSingleThreadExecutor() }

    private fun triggerSmartProtectionImpl(service: AppProtection, online: Boolean, promise: Promise) {
        smartProtectionRequests.add(promise)
        if (smartProtectionRequests.size == 1) {
            // First item added, execute request on another background thread to do not block
            // module's main execution queue
            smartProtectionExecutor.execute {
                val result = try {
                    Result.success(service.getAntivirus().getSmartProtectionManager().performSingleSmartProtectionUpdate(online))
                } catch (t: Throwable) {
                    Result.failure(t)
                }
                executeOnQueue {
                    // Process result back on module's main queue
                    smartProtectionRequests.forEach { result.map { it.toJs() }.report(it) }
                    smartProtectionRequests.clear()
                }
            }
        }
    }

    @ReactMethod
    fun getThreatList(promise: Promise) {
        resolveOnQueue(promise) { service ->
            service.getAntivirus().evaluateThreats().toJs { it.toJs() }
        }
    }

    // TODO: fix deprecation
    @Suppress("DEPRECATION")
    @ReactMethod
    fun getApkInfo(packageName: String?, promise: Promise) {
        resolveOnQueue(promise) {
            if (packageName == null) {
                throw InvalidParameterException("packageName")
            }
            try {
                val pm = reactApplicationContext.packageManager
                val label = pm.getApplicationLabel(pm.getApplicationInfo(packageName, PackageManager.GET_META_DATA))
                val icon = (pm.getApplicationIcon(packageName) as? BitmapDrawable)?.let { bd ->
                    val stream = ByteArrayOutputStream()
                    bd.bitmap.compress(Bitmap.CompressFormat.PNG, 100, stream)
                    encodeToString(stream.toByteArray(), android.util.Base64.DEFAULT)
                }
                Arguments.createMap()
                    .put("label", label)
                    .put("icon", icon)
            } catch (e: Throwable) {
                null
            }
        }
    }

    // Module state and other private functions

    private val appProtectionService = AppProtection.getInstance()
    private val serialExecutor = Executors.newSingleThreadExecutor()

    private fun changeState(newState: State) {
        moduleState = newState
        sendEvent(Event.STATE, newState.name, false)
    }

    private fun checkExpectedState(expectedState: State?) {
        if (expectedState != null) {
            if (this.moduleState != expectedState) {
                throw WrongStateException(this.moduleState, expectedState)
            }
            if (expectedState == State.READY && !this.appProtectionService.isInitialized()) {
                throw InternalError("AppProtection not initialized in READY state")
            }
        }
    }

    private fun <TResult> resolveOnQueue(promise: Promise, expectedState: State? = State.READY, action: (service: AppProtection) -> TResult) {
        executeOnQueue {
            try {
                checkExpectedState(expectedState)
                val result = action(appProtectionService)
                if (result == null || result is Unit) {
                    promise.resolve(null)
                } else {
                    promise.resolve(result)
                }
            } catch (e: Throwable) {
                e.reject(promise)
            }
        }
    }

    private fun onQueue(promise: Promise, expectedState: State? = State.READY, action: (service: AppProtection) -> Unit) {
        executeOnQueue {
            try {
                checkExpectedState(expectedState)
                action(appProtectionService)
            } catch (e: Throwable) {
                e.reject(promise)
            }
        }
    }

    private fun onQueue(action: (service: AppProtection) -> Unit) {
        executeOnQueue {
            try {
                action(appProtectionService)
            } catch (e: Throwable) {
                RNLog.l("Background task failed: $e")
            }
        }
    }

    /**
     * Execute action on the internal serial queue. If the current thread is already the thread
     * associated to the queue, then execute action immediately.
     *
     * Note that this method doesn't handle exceptions.
     */
    private fun executeOnQueue(action: () -> Unit) {
        if (Thread.currentThread().id == serialExecutorThread) {
            action()
        } else {
            serialExecutor.execute(action)
        }
    }

    private var serialExecutorThread: Long = -1
    init {
        serialExecutor.execute {
            // Capture the thread identifier for optimized tasks execution.
            serialExecutorThread = Thread.currentThread().id
            // Release service if it's somehow already initialized.
            if (appProtectionService.isInitialized()) {
                RNLog.w(reactContext, "AppProtection service is already initialized")
                appProtectionService.release()
            }
        }
    }
}
