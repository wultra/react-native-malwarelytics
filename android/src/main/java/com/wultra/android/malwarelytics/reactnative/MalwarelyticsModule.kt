//
// Copyright 2023 Wultra s.r.o.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.
//

package com.wultra.android.malwarelytics.reactnative

import android.content.pm.PackageManager
import android.graphics.Bitmap
import android.graphics.drawable.BitmapDrawable
import android.util.Base64.encodeToString
import com.facebook.react.bridge.Arguments
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.bridge.ReactContextBaseJavaModule
import com.facebook.react.bridge.ReactMethod
import com.facebook.react.bridge.Promise
import com.facebook.react.bridge.ReadableArray
import com.facebook.react.bridge.ReadableMap
import com.facebook.react.util.RNLog
import com.wultra.android.appprotection.AppProtection
import com.wultra.android.appprotection.AppProtectionConfig
import com.wultra.android.rasp.*
import java.io.ByteArrayOutputStream
import java.util.concurrent.Executor
import java.util.concurrent.Executors

/**
 * Class implements `MalwarelyticsModule` object exposed to JavaScript.
 */
class MalwarelyticsModule(reactContext: ReactApplicationContext) :
    ReactContextBaseJavaModule(reactContext) {

    /**
     * Module states
     */
    enum class State {
        SHUTDOWN,
        PENDING_INIT,
        READY,
        PENDING_SHUTDOWN
    }

    /**
     * Events supported by this module.
     */
    enum class Event(val value: String) {
        STATE("Malwarelytics.STATE"),
        RASP("Malwarelytics.RASP"),
        AV("Malwarelytics.AV"),
    }

    /**
     * Current module state.
     */
    private var moduleState = State.SHUTDOWN
    /**
     * Last initialization result.
     */
    private var moduleInitResult: AppProtection.InitializationResult? = null

    // React Native Module

    override fun getName(): String {
        return "Malwarelytics"
    }

    override fun invalidate() {
        super.invalidate()
        // RN is going to reload environment
        onQueue { service ->
            if (moduleState == State.READY) {
                releaseService(service, clearAvUserId = false, notify = false)
            }
        }
    }

    // Logging

    /**
     * Print warning to the console. The function is using [RNLog] under the hood.
     */
    private fun printWarning(message: String) {
        if (BuildConfig.DEBUG) {
            RNLog.l("WARNING: $message")
        }
    }

    /**
     * Print error to the console. The function is using [RNLog] under the hood.
     */
    private fun printError(message: String) {
        if (BuildConfig.DEBUG) {
            RNLog.l("ERROR: $message")
        }
    }

    // Events

    /**
     * EventHelper instance that helps with sending  events back to JS
     */
    private val eventHelper = EventHelper(Event.values().map { it.value }, reactContext)

    @ReactMethod
    fun getSupportedEvents(promise: Promise) {
        promise.resolve(eventHelper.supportedEvents.toJs())
    }

    @ReactMethod
    fun addListener(eventName: String) {
        eventHelper.addListener(eventName)
    }

    @ReactMethod
    fun removeListeners(count: Int) {
        eventHelper.removeListeners(count)
    }

    /**
     * Send event back to the JavaScript.
     * @param event Event type to send
     * @param body Event content. It must contain [ReadableMap], [ReadableArray] or other objects supported by React Native.
     * @param checkState If true (default), then function check whether the current state is READY. If module is in different state, then prints warning to the console.
     */
    private fun sendEvent(event: Event, body: Any, checkState: Boolean = true) {
        onQueue {
            if (checkState && moduleState != State.READY) {
                printWarning("Cannot send event ${event.value} because module is not in READY state")
            } else {
                eventHelper.sendEvent(event.value, body)
            }
        }
    }


    // Exported methods

    @ReactMethod
    fun initialize(config: ReadableMap?, promise: Promise) {
        onQueue(promise, State.SHUTDOWN) { service ->
            if (config == null) {
                throw MissingParameterException("configuration")
            }
            // Convert config first, before we start with the initialization
            val appProtectionConfig = config.toAppProtectionConfig(reactApplicationContext.applicationContext, javaPackagePath)
            initializeService(service, appProtectionConfig, promise)
        }
    }

    @ReactMethod
    fun shutdown(clearAvUserId: Boolean, promise: Promise) {
        resolveOnQueue(promise) { service ->
            releaseService(service, clearAvUserId, true)
        }
    }

    /**
     * Initialize native service with the config.
     * @param service Instance of [AppProtection].
     * @param config [AppProtectionConfig] instance.
     * @param promise [Promise] for the future completion.
     */
    private fun initializeService(service: AppProtection, config: AppProtectionConfig, promise: Promise) {
        changeState(State.PENDING_INIT)
        service.initializeAsync(config, object : AppProtection.InitializationObserver {
            override fun onInitialized(initializationResult: AppProtection.InitializationResult) {
                // Protect the current activity against tapjacking. We're already on the main thread.
                val activity = reactApplicationContext.currentActivity
                if (activity != null) {
                    service.getRaspManager().protectActivity(activity)
                }
                // Now process the initialization result in worker's thread
                resolveOnQueue(promise, null) {
                    changeState(State.READY)
                    moduleInitResult = initializationResult
                    service.getRaspManager().registerRaspObserver(raspObserver)
                    // Resolve the promise with initialization result
                    initializationResult.name
                }
            }
        })
    }

    /**
     * Release native service. The function must be called from the thread provided by internal serial queue.
     * @param service Instance of [AppProtection].
     * @param clearAvUserId If `true`, then also release AV user ID.
     */
    private fun releaseService(service: AppProtection, clearAvUserId: Boolean, notify: Boolean) {
        if (notify) {
            changeState(State.PENDING_SHUTDOWN)
        }
        service.getRaspManager().unregisterRaspObserver(raspObserver)
        if (clearAvUserId) {
            service.releaseAndResetAvUid()
        } else {
            service.release()
        }
        raspEventsMap.clear()
        moduleInitResult = null
        // Cancel possible smart protection requests
        smartProtectionRequests.forEach { promise -> InternalError("Canceled due to service release").reject(promise) }
        smartProtectionRequests.clear()

        if (notify) {
            changeState(State.SHUTDOWN)
        } else {
            moduleState = State.SHUTDOWN
        }
    }


    @ReactMethod
    fun getState(promise: Promise) {
        resolveOnQueue(promise, null) {
            Arguments.createMap()
                .put("state", moduleState.name)
                .put("result", moduleInitResult?.name)
        }
    }

    @ReactMethod
    fun setClientId(clientId: String?, promise: Promise) {
        resolveOnQueue(promise) { service ->
            service.updateClientAppDeviceId(clientId)
        }
    }

    @ReactMethod
    fun setDeviceId(deviceId: String?, promise: Promise) {
        resolveOnQueue(promise) { service ->
            service.updateClientAppDeviceId(deviceId)
        }
    }

    @ReactMethod
    fun getAvUserId(promise: Promise) {
        resolveOnQueue(promise) { service ->
            service.getAvUserId()
        }
    }

    @ReactMethod
    fun getRaspInfo(message: String?, promise: Promise) {
        resolveOnQueue(promise) { service ->
            if (message == null) {
                throw MissingParameterException("message")
            }
            val messageType = try {
                RaspMessageType.valueOf(message)
            } catch (e: Throwable) {
                throw InvalidParameterException("message", e)
            }
            getRaspInfo(service, messageType)
        }
    }

    /**
     * Return RASP info depending on type of message requested.
     * @param service Instance of [AppProtection] service.
     * @param message Message type
     * @return Object supported by React Native (e.g. [ReadableMap], [ReadableArray], `Boolean`, etc...)
     */
    private fun getRaspInfo(service: AppProtection, message: RaspMessageType): Any? {
        val rasp = service.getRaspManager()
        return when (message) {
            RaspMessageType.DEBUGGER -> rasp.isDebuggerAttached()
            RaspMessageType.SYSTEM_INTEGRITY -> rasp.getRootDetection().toJs()
            RaspMessageType.REPACKAGED -> rasp.isAppRepackaged().toString()
            RaspMessageType.HTTP_PROXY -> rasp.getHttpProxyDetection().toJs()
            RaspMessageType.SCREEN_SHARING -> rasp.getScreenSharingDetection().toJs()
            RaspMessageType.EMULATOR -> rasp.getEmulatorDetection().toJs()
            RaspMessageType.VPN -> rasp.isVpnEnabled()
            RaspMessageType.TAPJACKING -> rasp.getTapjackingDetection().toJs()
            RaspMessageType.ADB_STATUS -> rasp.isAdbEnabled()
            RaspMessageType.NA_SCREEN_READER -> rasp.isNotAllowedScreenReaderEnabled()
            RaspMessageType.SCREEN_LOCK -> rasp.isDeviceUsingScreenLock()
            RaspMessageType.PLAY_PROTECT -> rasp.isPlayProtectEnabled()
            RaspMessageType.TAPJACKING_APP_PRESENT -> rasp.isBadTapjackingCapableAppPresent()
            RaspMessageType.DEVELOPER_MODE -> rasp.isDeveloperOptionsEnabled()
        }
    }

    // Private methods

    /**
     * Java package name extracted from this class.
     */
    private val javaPackagePath: String
        get() = "${this.javaClass.`package`?.name}"


    // Observing RASP events

    /**
     * Messages supported by the RASP part of Malwarelytics.
     */
    private enum class RaspMessageType {
        // Following types are accessed by the getter and also reported from the listener.
        DEBUGGER,
        SYSTEM_INTEGRITY,
        REPACKAGED,
        HTTP_PROXY,
        SCREEN_SHARING,
        EMULATOR,
        VPN,
        TAPJACKING,
        ADB_STATUS,
        // Following types are accessed only by the getter.
        SCREEN_LOCK,
        PLAY_PROTECT,
        NA_SCREEN_READER,
        TAPJACKING_APP_PRESENT,
        DEVELOPER_MODE
    }

    /**
     * Object implements [RaspObserver] interface.
     */
    private val raspObserver = object: RaspObserver {
        override fun onAdbStatusDetected(adbStatus: Boolean) {
            sendRaspEvent(RaspMessageType.ADB_STATUS, adbStatus, adbStatus)
        }

        override fun onDebuggerDetected(debuggerDetected: Boolean) {
            sendRaspEvent(RaspMessageType.DEBUGGER, debuggerDetected, debuggerDetected)
        }

        override fun onEmulatorDetected(emulatorDetection: EmulatorDetection) {
            sendRaspEvent(RaspMessageType.EMULATOR, emulatorDetection.toJs(), emulatorDetection.isEmulator)
        }

        override fun onHttpProxyDetected(httpProxyDetection: HttpProxyDetection) {
            sendRaspEvent(RaspMessageType.HTTP_PROXY, httpProxyDetection.toJs(), httpProxyDetection.isHttpProxyEnabled)
        }

        override fun onRepackagingDetected(repackagingResult: RepackagingResult) {
            sendRaspEvent(RaspMessageType.REPACKAGED, repackagingResult.toString(), repackagingResult != RepackagingResult.ORIGINAL_APP)
        }

        override fun onRootDetected(rootDetection: RootDetection) {
            sendRaspEvent(RaspMessageType.SYSTEM_INTEGRITY, rootDetection.toJs(), rootDetection.isRooted)
        }

        override fun onScreenSharingDetected(screenSharingDetected: Boolean) {
            sendRaspEvent(RaspMessageType.SCREEN_SHARING, simpleWritableMap("isScreenShared", screenSharingDetected), screenSharingDetected)
        }

        override fun onTapjackingDetected(tapjackingDetection: TapjackingDetection) {
            sendRaspEvent(RaspMessageType.TAPJACKING, tapjackingDetection.toJs(), tapjackingDetection.isTapjackingBlocked)
        }

        override fun onVpnDetected(vpnEnabled: Boolean) {
            sendRaspEvent(RaspMessageType.VPN, vpnEnabled, vpnEnabled)
        }
    }

    /**
     * Report RASP event back to the JavaScript.
     * @param messageType RASP message type
     * @param body Content of message, depending on type.
     * @param important Message is important and should be always reported back to JavaScript.
     */
    private fun sendRaspEvent(messageType: RaspMessageType, body: Any, important: Boolean) {
        onQueue {
            if (shouldReportEvent(messageType, body, important)) {
                val payload = Arguments.createMap()
                payload.put("type", messageType.name)
                payload.putAny("payload", body)
                sendEvent(Event.RASP, payload)
            }
        }
    }

    /**
     * Map with last events.
     */
    private val raspEventsMap = mutableMapOf<String, String>()

    /**
     * Determine whether RASP event type should be reported or not. When the service starts, some events
     * can be omitted when message is not important. The function also filter events when the content
     * of the message is the same as previous.
     *
     * @param messageType RASP message type
     * @param body Data reported from the native code.
     * @param important If `true` then message is important.
     *
     * @return `true` if RASP event should be reported back to JavaScript.
     */
    private fun shouldReportEvent(messageType: RaspMessageType, body: Any, important: Boolean): Boolean {
        val key = messageType.name
        val lastValue = raspEventsMap[key]
        val currentValue = when (body) {
            is String -> body
            is ReadableMap -> body.toHashMap().toString()
            is ReadableArray -> body.toArrayList().toString()
            is Boolean -> if (body) "true" else "false"
            else -> throw java.lang.IllegalArgumentException("Unsupported body in message")
        }
        if (lastValue == null) {
            // This is initial state, no previous event was captured
            raspEventsMap[key] = currentValue
            return important
        }
        if (currentValue != lastValue) {
            raspEventsMap[key] = currentValue
            return true
        }
        // No change since last event
        return false
    }

    // Antivirus

    @ReactMethod
    fun isAntivirusEnabled(promise: Promise) {
        resolveOnQueue(promise) { service ->
            service.isAntivirusEnabled()
        }
    }

    @ReactMethod
    fun setAntivirusLocalization(code: String?, promise: Promise) {
        resolveOnQueue(promise) { service ->
            service.getAntivirus().getSmartProtectionManager().setCustomLocalization(code)
        }
    }

    @ReactMethod
    fun getAntivirusLocalization(promise: Promise) {
        resolveOnQueue(promise) { service ->
            service.getAntivirus().getSmartProtectionManager().getCustomLocalization()
        }
    }

    @ReactMethod
    fun triggerSmartProtection(performOnlineUpdate: Boolean, promise: Promise) {
        onQueue(promise) { service ->
            triggerSmartProtectionImpl(service, performOnlineUpdate, promise)
        }
    }

    @ReactMethod
    fun isSmartProtectionTriggered(promise: Promise) {
        resolveOnQueue(promise) {
            smartProtectionRequests.isNotEmpty()
        }
    }

    /**
     * List of issued calls to `triggerSmartProtection()`
     */
    private val smartProtectionRequests = mutableListOf<Promise>()
    /**
     * Executor used exclusively for call to Smart Protection evaluation. The task may take a longer
     * time than expected, so we don't want to block the main working queue.
     */
    private val smartProtectionExecutor: Executor by lazy { Executors.newSingleThreadExecutor() }

    /**
     * Execute Smart Protection update on a special executor and keep track of issued JavaScript promises.
     * @param service Instance of [AppProtection] service.
     * @param online Whether online update is requested.
     * @param promise [Promise] to complete.
     */
    private fun triggerSmartProtectionImpl(service: AppProtection, online: Boolean, promise: Promise) {
        smartProtectionRequests.add(promise)
        if (smartProtectionRequests.size == 1) {
            // First item added, execute request on another background thread to do not block
            // module's main execution queue
            smartProtectionExecutor.execute {
                val result = try {
                    Result.success(service.getAntivirus().getSmartProtectionManager().performSingleSmartProtectionUpdate(online))
                } catch (t: Throwable) {
                    Result.failure(t)
                }
                executeOnQueue {
                    // Process result back on module's main queue
                    smartProtectionRequests.forEach { promise -> result.map { it.toJs() }.report(promise) }
                    smartProtectionRequests.clear()
                }
            }
        }
    }

    @ReactMethod
    fun getThreatList(promise: Promise) {
        resolveOnQueue(promise) { service ->
            service.getAntivirus().evaluateThreats().toJs { it.toJs() }
        }
    }

    // TODO: fix deprecation
    @Suppress("DEPRECATION")
    @ReactMethod
    fun getApkInfo(packageName: String?, promise: Promise) {
        resolveOnQueue(promise) {
            if (packageName == null) {
                throw InvalidParameterException("packageName")
            }
            try {
                val pm = reactApplicationContext.packageManager
                val label = pm.getApplicationLabel(pm.getApplicationInfo(packageName, PackageManager.GET_META_DATA))
                val icon = (pm.getApplicationIcon(packageName) as? BitmapDrawable)?.let { bd ->
                    val stream = ByteArrayOutputStream()
                    bd.bitmap.compress(Bitmap.CompressFormat.PNG, 100, stream)
                    encodeToString(stream.toByteArray(), android.util.Base64.DEFAULT)
                }
                Arguments.createMap()
                    .put("label", label)
                    .put("icon", icon)
            } catch (e: Throwable) {
                null
            }
        }
    }

    // Module state and other private functions

    /**
     * Instance of `AppProtection`. Do not use this value directly.
     */
    private val appProtectionService = AppProtection.getInstance()
    /**
     * Internal serial execution queue that provides the thread synchronization.
     */
    private val serialExecutor = Executors.newSingleThreadExecutor()

    /**
     * Change module's state and notify the JavaScript world about this change.
     * @param newState New module's state.
     */
    private fun changeState(newState: State) {
        moduleState = newState
        sendEvent(Event.STATE, newState.name, false)
    }

    /**
     * Check whether the module is in expected state. If state is unexpected, or [AppProtection]
     * service is not in expected state, then throws exception.
     *
     * @param If provided, then the module must be in the requested state.
     */
    private fun checkExpectedState(expectedState: State?) {
        if (expectedState != null) {
            if (this.moduleState != expectedState) {
                throw WrongStateException(this.moduleState, expectedState)
            }
            if (expectedState == State.READY && !this.appProtectionService.isInitialized()) {
                throw InternalError("AppProtection not initialized in READY state")
            }
        }
    }

    /**
     * Resolve or reject promise on the serial queue by executing provided closure.
     *
     * @param promise [Promise] to reject or resolve.
     * @param expectedState If not null, then the module must be in this particular state.
     * @param action Action to execute and resolve the promise. If execution fails with exception, then the promise is rejected.
     */
    private fun <TResult> resolveOnQueue(promise: Promise, expectedState: State? = State.READY, action: (service: AppProtection) -> TResult) {
        executeOnQueue {
            try {
                checkExpectedState(expectedState)
                val result = action(appProtectionService)
                if (result == null || result is Unit) {
                    promise.resolve(null)
                } else {
                    promise.resolve(result)
                }
            } catch (e: Throwable) {
                e.reject(promise)
            }
        }
    }

    /**
     * Execute provided closure on the serial queue. If execution fails, then reject the provided promise. Unlike [resolveOnQueue], this
     * function doesn't resolve the promise. It's expected that promise is resolved later, after other asynchronous task is completed.
     * @param promise [Promise] to reject in case of failure.
     * @param expectedState If not null, then the module must be in this particular state.
     * @param action Action to execute on the serial queue. If execution fails with exception, then the promise is rejected.
     */
    private fun onQueue(promise: Promise, expectedState: State? = State.READY, action: (service: AppProtection) -> Unit) {
        executeOnQueue {
            try {
                checkExpectedState(expectedState)
                action(appProtectionService)
            } catch (e: Throwable) {
                e.reject(promise)
            }
        }
    }

    /**
     * Execute provided closure on the serial queue. If execution fails, then the exception is consumed and reported to the console.
     * @param action Action to execute on the serial queue.
     */
    private fun onQueue(action: (service: AppProtection) -> Unit) {
        executeOnQueue {
            try {
                action(appProtectionService)
            } catch (e: Throwable) {
                printError("Background task failed: $e")
            }
        }
    }

    /**
     * Execute action on the internal serial queue. If the current thread is already the thread
     * associated to the queue, then execute action immediately.
     *
     * Note that this method doesn't handle exceptions.
     */
    private fun executeOnQueue(action: () -> Unit) {
        if (Thread.currentThread().id == serialExecutorThread) {
            action()
        } else {
            serialExecutor.execute(action)
        }
    }

    /**
     * Identifier of thread used by the serial executor.
     */
    private var serialExecutorThread: Long = -1

    init {
        serialExecutor.execute {
            // Capture the thread identifier for optimized tasks execution.
            serialExecutorThread = Thread.currentThread().id
            // Release service if it's somehow already initialized.
            if (appProtectionService.isInitialized()) {
                printWarning("AppProtection service is already initialized")
                appProtectionService.release()
            }
        }
    }
}
