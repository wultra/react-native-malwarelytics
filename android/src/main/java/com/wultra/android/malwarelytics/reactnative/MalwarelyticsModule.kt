//
// Copyright 2023 Wultra s.r.o.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.
//

package com.wultra.android.malwarelytics.reactnative

import com.facebook.react.bridge.Arguments
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.bridge.ReactContextBaseJavaModule
import com.facebook.react.bridge.ReactMethod
import com.facebook.react.bridge.Promise
import com.facebook.react.bridge.ReadableArray
import com.facebook.react.bridge.ReadableMap
import com.facebook.react.util.RNLog
import com.wultra.android.appprotection.AppProtection
import com.wultra.android.rasp.*
import java.util.concurrent.Executors

class MalwarelyticsModule(reactContext: ReactApplicationContext) :
    ReactContextBaseJavaModule(reactContext) {

    enum class State {
        SHUTDOWN,
        PENDING_INIT,
        READY,
        PENDING_SHUTDOWN
    }

    enum class Event(val value: String) {
        STATE("Malwarelytics.STATE"),
        RASP("Malwarelytics.RASP")
    }

    private var moduleState = State.SHUTDOWN
    private var moduleInitResult: AppProtection.InitializationResult? = null

    override fun getName(): String {
        return "Malwarelytics"
    }

    override fun initialize() {
        super.initialize()
        RNLog.l("Initialize")
    }

    override fun invalidate() {
        super.invalidate()
        if (moduleState == State.READY) {
            releaseService(appProtectionService)
        }
    }

    // Events

    val eventHelper = EventHelper(arrayListOf(Event.STATE.value, Event.RASP.value), reactContext)

    @ReactMethod
    fun getSupportedEvents(promise: Promise) {
        promise.resolve(eventHelper.supportedEvents.toJs())
    }

    @ReactMethod
    fun addListener(eventName: String) {
        eventHelper.addListener(eventName)
    }

    @ReactMethod
    fun removeListeners(count: Int) {
        eventHelper.removeListeners(count)
    }

    private fun sendEvent(event: Event, body: Any, checkState: Boolean = true) {
        onQueue {
            if (checkState && moduleState != State.READY) {
                RNLog.w(reactApplicationContext, "Cannot send event ${event.value} because module is not in READY state")
            } else {
                eventHelper.sendEvent(event.value, body)
            }
        }
    }


    // Exported methods

    @ReactMethod
    fun initialize(config: ReadableMap?, promise: Promise) {
        onQueue(promise) { service ->
            if (moduleState != State.SHUTDOWN) {
                throw WrongStateException("Initialize", moduleState, State.SHUTDOWN)
            }
            if (config == null) {
                throw MissingParameterException("configuration")
            }
            changeState(State.PENDING_INIT)
            service.initializeAsync(config.toAppProtectionConfig(reactApplicationContext.applicationContext), object : AppProtection.InitializationObserver {
                override fun onInitialized(initializationResult: AppProtection.InitializationResult) {
                    resolveOnQueue(promise) {
                        changeState(State.READY)
                        moduleInitResult = initializationResult
                        service.getRaspManager().registerRaspObserver(raspObserver)
                        initializationResult.name
                    }
                }
            })
        }
    }

    @ReactMethod
    fun shutdown(promise: Promise) {
        resolveOnQueue(promise) { service ->
            if (moduleState != State.READY) {
                throw WrongStateException("Shutdown", moduleState, State.READY)
            }
            changeState(State.PENDING_SHUTDOWN)
            releaseService(service)
            changeState(State.SHUTDOWN)
        }
    }

    @ReactMethod
    fun getState(promise: Promise) {
        resolveOnQueue(promise) {
            val result = simpleWritableMap("state", moduleState.name)
            result.put("result", moduleInitResult?.name)
            result
        }
    }

    @ReactMethod
    fun setClientId(clientId: String?, promise: Promise) {
        resolveOnQueue(promise) { service ->
            if (moduleState != State.READY) {
                throw WrongStateException("setClientId", moduleState, State.READY)
            }
            service.updateClientAppDeviceId(clientId)
        }
    }

    @ReactMethod
    fun setDeviceId(deviceId: String?, promise: Promise) {
        resolveOnQueue(promise) { service ->
            if (moduleState != State.READY) {
                throw WrongStateException("setDeviceId", moduleState, State.READY)
            }
            service.updateClientAppDeviceId(deviceId)
        }
    }

    @ReactMethod
    fun getRaspInfo(message: String?, promise: Promise) {
        resolveOnQueue(promise) { service ->
            if (message == null) {
                throw MissingParameterException("message")
            }
            if (moduleState != State.READY) {
                throw WrongStateException("getRaspInfo", moduleState, State.READY)
            }
            val messageType = try {
                RaspMessageType.valueOf(message)
            } catch (e: Throwable) {
                throw InvalidParameterException("message", e)
            }
            getRaspInfo(service, messageType)
        }
    }
    private fun getRaspInfo(service: AppProtection, message: RaspMessageType): Any {
        val rasp = service.getRaspManager()
        return when (message) {
            RaspMessageType.DEBUGGER -> rasp.isDebuggerAttached()
            RaspMessageType.SYSTEM_INTEGRITY -> rasp.getRootDetection().toJs()
            RaspMessageType.REPACKAGED -> rasp.isAppRepackaged().toString()
            RaspMessageType.HTTP_PROXY -> rasp.getHttpProxyDetection().toJs()
            RaspMessageType.SCREEN_SHARING -> rasp.getScreenSharingDetection().toJs()
            RaspMessageType.EMULATOR -> rasp.getEmulatorDetection().toJs()
            RaspMessageType.VPN -> rasp.isVpnEnabled()
            RaspMessageType.TAPJACKING -> rasp.getTapjackingDetection().toJs()
            RaspMessageType.ADB_STATUS -> rasp.isAdbEnabled()
        }
    }

    // Service

    private fun releaseService(service: AppProtection) {
        service.getRaspManager().unregisterRaspObserver(raspObserver)
        service.release()
        raspEventsMap.clear()
        moduleInitResult = null
    }

    // Private methods

    // Observing RASP events

    private enum class RaspMessageType {
        DEBUGGER,
        SYSTEM_INTEGRITY,
        REPACKAGED,
        HTTP_PROXY,
        SCREEN_SHARING,
        EMULATOR,
        VPN,
        TAPJACKING,
        ADB_STATUS
    }

    private val raspObserver = object: RaspObserver {
        override fun onAdbStatusDetected(adbStatus: Boolean) {
            sendRaspEvent(RaspMessageType.ADB_STATUS, adbStatus, adbStatus)
        }

        override fun onDebuggerDetected(debuggerDetected: Boolean) {
            sendRaspEvent(RaspMessageType.DEBUGGER, debuggerDetected, debuggerDetected)
        }

        override fun onEmulatorDetected(emulatorDetection: EmulatorDetection) {
            sendRaspEvent(RaspMessageType.EMULATOR, emulatorDetection.toJs(), emulatorDetection.isEmulator)
        }

        override fun onHttpProxyDetected(httpProxyDetection: HttpProxyDetection) {
            sendRaspEvent(RaspMessageType.HTTP_PROXY, httpProxyDetection.toJs(), httpProxyDetection.isHttpProxyEnabled)
        }

        override fun onRepackagingDetected(repackagingResult: RepackagingResult) {
            sendRaspEvent(RaspMessageType.REPACKAGED, repackagingResult.toString(), repackagingResult != RepackagingResult.ORIGINAL_APP)
        }

        override fun onRootDetected(rootDetection: RootDetection) {
            sendRaspEvent(RaspMessageType.SYSTEM_INTEGRITY, rootDetection.toJs(), rootDetection.isRooted)
        }

        override fun onScreenSharingDetected(screenSharingDetected: Boolean) {
            sendRaspEvent(RaspMessageType.SCREEN_SHARING, simpleWritableMap("isScreenShared", screenSharingDetected), screenSharingDetected)
        }

        override fun onTapjackingDetected(tapjackingDetection: TapjackingDetection) {
            sendRaspEvent(RaspMessageType.TAPJACKING, tapjackingDetection.toJs(), tapjackingDetection.isTapjackingBlocked)
        }

        override fun onVpnDetected(vpnEnabled: Boolean) {
            sendRaspEvent(RaspMessageType.VPN, vpnEnabled, vpnEnabled)
        }
    }

    private fun sendRaspEvent(messageType: RaspMessageType, body: Any, important: Boolean) {
        onQueue {
            if (shouldReportEvent(messageType, body, important)) {
                val payload = Arguments.createMap()
                payload.put("type", messageType.name)
                payload.putAny("payload", body)
                sendEvent(Event.RASP, payload)
            }
        }
    }

    // RASP event filter

    private val raspEventsMap = mutableMapOf<String, String>()

    /**
     * Determine whether event type should be reported or not. When the service starts, some events
     * can be omitted when message is not important. The function also filter events when the content
     * of the message is the same as previous.
     */
    private fun shouldReportEvent(messageType: RaspMessageType, body: Any, important: Boolean): Boolean {
        val key = messageType.name
        val lastValue = raspEventsMap[key]
        val currentValue = when (body) {
            is String -> body
            is ReadableMap -> body.toHashMap().toString()
            is ReadableArray -> body.toArrayList().toString()
            is Boolean -> if (body) "true" else "false"
            else -> throw java.lang.IllegalArgumentException("Unsupported body in message")
        }
        if (lastValue == null) {
            // This is initial state, no previous event was captured
            raspEventsMap[key] = currentValue
            return important
        }
        if (currentValue != lastValue) {
            raspEventsMap[key] = currentValue
            return true
        }
        // No change since last event
        return false
    }

    // Module state and other private functions

    private val appProtectionService = AppProtection.getInstance()
    private val serialExecutor = Executors.newSingleThreadExecutor()

    private fun changeState(newState: State) {
        moduleState = newState
        sendEvent(Event.STATE, newState.name, false)
    }

    private fun <TResult> resolveOnQueue(promise: Promise, action: (service: AppProtection) -> TResult) {
        executeOnQueue {
            try {
                val result = action(appProtectionService)
                if (result is Unit) {
                    promise.resolve(null)
                } else {
                    promise.resolve(result)
                }
            } catch (e: Throwable) {
                e.reject(promise)
            }
        }
    }

    private fun onQueue(promise: Promise, action: (service: AppProtection) -> Unit) {
        executeOnQueue {
            try {
                action(appProtectionService)
            } catch (e: Throwable) {
                e.reject(promise)
            }
        }
    }

    private fun onQueue(action: (service: AppProtection) -> Unit) {
        executeOnQueue {
            try {
                action(appProtectionService)
            } catch (e: Throwable) {
                RNLog.l("Background task failed: $e")
            }
        }
    }

    private fun executeOnQueue(action: () -> Unit) {
        if (Thread.currentThread().id == serialExecutorThread) {
            action()
        } else {
            serialExecutor.execute(action)
        }
    }

    private var serialExecutorThread: Long = -1
    init {
        serialExecutor.execute {
            serialExecutorThread = Thread.currentThread().id
        }
    }
}
