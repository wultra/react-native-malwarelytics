//
// Copyright 2023 Wultra s.r.o.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.
//

package com.wultra.android.malwarelytics.reactnative

import android.content.Context
import com.facebook.react.bridge.ReadableMap
import com.wultra.android.antimalware.AntivirusConfig
import com.wultra.android.antimalware.ThreatIndex
import com.wultra.android.appprotection.AppProtectionConfig
import com.wultra.android.rasp.config.AdbDetectionConfig
import com.wultra.android.rasp.config.AppPresenceDetectionConfig
import com.wultra.android.rasp.config.BlockConfig
import com.wultra.android.rasp.config.DebuggerDetectionConfig
import com.wultra.android.rasp.config.DetectionConfig
import com.wultra.android.rasp.config.ProcessNameConfig
import com.wultra.android.rasp.config.RepackageDetectionConfig
import com.wultra.android.rasp.config.RootDetectionConfig
import com.wultra.android.rasp.config.ScreenReaderBlockConfig
import com.wultra.android.rasp.config.SimpleDetectionConfig
import com.wultra.android.rasp.config.TapjackingBlockConfig
import com.wultra.android.rasp.DebuggerType
import com.wultra.android.rasp.RaspConfig

/**
 * Create [AppProtectionConfig] from [ReadableMap].
 * @param context Android context
 * @param javaPackagePath Path to Java package.
 */
fun ReadableMap.toAppProtectionConfig(context: Context, javaPackagePath: String): AppProtectionConfig {
    // RASP
    val raspBuilder = RaspConfig.Builder()
    mapOptAt("android.rasp")?.apply {
        val jsObj = "MalwarelyticsAndroidRaspConfig"
        val jsScreenReaders = "MalwarelyticsAndroidRaspScreenReadersBlockConfig"
        mapOptAt("emulator", jsObj)?.let {
            raspBuilder.emulator(it.toDetectionConfig("emulator"))
        }
        mapOptAt("root", jsObj)?.let {
            raspBuilder.root(it.toRootDetectionConfig())
        }
        mapOptAt("debugger", jsObj)?.let {
            raspBuilder.debugger(it.toDebuggerDetectionConfig())
        }
        mapOptAt("repackage", jsObj)?.let {
            raspBuilder.repackage(it.toRepackageDetectionConfig())
        }
        mapOptAt("screenSharing", jsObj)?.let {
            raspBuilder.screenSharing(it.toDetectionConfig("screenSharing"))
        }
        mapOptAt("screenshot", jsObj)?.let {
            raspBuilder.screenshot(it.toBlockConfig("screenshot"))
        }
        mapOptAt("screenReader", jsObj)?.let {
            raspBuilder.screenReader(it.toScreenReaderBlockConfig())
        }
        mapOptAt("processName", jsObj)?.let {
            raspBuilder.processName(it.toProcessNameConfig())
        }
        mapOptAt("tapjacking", jsObj)?.let {
            raspBuilder.tapjacking(it.toTapjackingBlockConfig())
        }
        mapOptAt("httpProxy", jsObj)?.let {
            raspBuilder.httpProxy(it.toDetectionConfig("httpProxy"))
        }
        mapOptAt("vpn", jsObj)?.let {
            raspBuilder.vpn(it.toDetectionConfig("vpn"))
        }
        mapOptAt("adb", jsObj)?.let {
            raspBuilder.adb(it.toAdbDetectionConfig())
        }
        mapOptAt("activeCall", jsObj)?.let {
            raspBuilder.activeCall(it.toSimpleDetectionConfig("activeCall"))
        }
        mapOptAt("appPresence", jsObj)?.let {
            raspBuilder.appPresence(it.toAppPresenceDetectionConfig())
        }
    }
    val raspConfig = raspBuilder.build()

    // Antivirus

    val avBuilder = AntivirusConfig.Builder()
    val spBuilder = AntivirusConfig.SmartProtectionConfig.Builder()
    val tmBuilder = AntivirusConfig.ThreatMitigationUIConfig.Builder()
    mapOptAt("android.antivirus")?.apply {
        val jsObj = "MalwarelyticsAndroidAntivirusConfig"
        boolOptAt("disable", jsObj)?.let { avBuilder.enableAntivirus(!it) }
        boolOptAt("enableSilentMode", jsObj)?.let { spBuilder.silentModeEnabled(it) }
        intOptAt("onlineCheckIntervalHours", jsObj)?.let { spBuilder.smartProtectionIntervalHours(it) }
        boolOptAt("updateOnInitialize", jsObj)?.let { spBuilder.performInitialFirstUpdate(it) }
    }

    stringOptAt("android.languageCode")?.let { tmBuilder.customLocalization(it) }
    val uiConfig = getMalwarelyticsUiConfig(javaPackagePath)
    uiConfig.theme?.let { tmBuilder.screenTheme(it) }
    uiConfig.notificationSmallIcon?.let { tmBuilder.notificationSmallIcon(it) }
    uiConfig.notificationChannelId?.let { tmBuilder.notificationChannelId(it) }
    uiConfig.screenSettingsIcon?.let { tmBuilder.screenSettingsIcon(it) }
    uiConfig.screenDeleteIcon?.let { tmBuilder.screenDeleteIcon(it) }

    val avConfig = avBuilder
        .threatMitigationUIConfig(tmBuilder.build())
        .smartProtectionConfig(spBuilder.build())
        .build()

    // Customer grouping

    val cgBuilder = AppProtectionConfig.CustomerGroupingConfig.Builder()
    mapOptAt("android.customerGrouping")?.apply {
        val jsObj = "MalwarelyticsAndroidCustomerGroupingConfig"
        stringOptAt("sourcePackageName", jsObj)?.let { cgBuilder.sourcePackageName(it) }
        stringOptAt("appPackageName", jsObj)?.let { cgBuilder.appPackageName(it) }
        stringOptAt("audienceGroupId", jsObj)?.let { cgBuilder.audienceGroupId(it) }
    }
    val cgConfig = cgBuilder.build()

    // Main configuration

    val builder = AppProtectionConfig.Builder(context)
    mapOptAt("android.service")?.apply {
        val jsObj = "MalwarelyticsServiceConfig"
        stringAt("username", jsObj).let { builder.apiUsername(it) }
        stringAt("password", jsObj).let { builder.apiPassword(it) }
        stringOptAt("signaturePublicKey", jsObj)?.let { builder.apiSignaturePublicKey(it) }
    }
    mapOptAt("clientIdentification")?.apply {
        val jsObj = "MalwarelyticsClientIdentification"
        stringOptAt("clientId", jsObj)?.let { builder.clientAppUserId(it) }
        stringOptAt("deviceId", jsObj)?.let { builder.clientAppDeviceId(it) }
    }
    val jsServiceConf = "MalwarelyticsServiceConfig"
    var environmentConfig = stringOptAt("android.service.environment", jsServiceConf)?.toEnvironmentConfiguration(jsServiceConf)
    if (environmentConfig == null) {
        environmentConfig = stringOptAt("environment", null)?.toEnvironmentConfiguration(null)
    }
    environmentConfig?.let { builder.environment(it) }

    stringOptAt("android.fingerprint")?.toFingerprintType()?.let {
        builder.fingerprint(it)
    }

    // Final config
    return builder
        .antivirusConfig(avConfig)
        .raspConfig(raspConfig)
        .customerGroupingConfig(cgConfig)
        .build()
}

private fun String.toEnvironmentConfiguration(objName: String?): AppProtectionConfig.EnvironmentConfiguration =
    when (this) {
        "PRODUCTION" -> AppProtectionConfig.EnvironmentConfiguration.PRODUCTION_ENVIRONMENT
        "TEST" -> AppProtectionConfig.EnvironmentConfiguration.TEST_ENVIRONMENT
        else -> throw InvalidConfigException("environment", objName)
    }

private fun String.toFingerprintType(): AppProtectionConfig.FingerprintType =
    when (this) {
        "NONE" -> AppProtectionConfig.FingerprintType.NONE
        "BASIC" -> AppProtectionConfig.FingerprintType.BASIC
        "SAFE" -> AppProtectionConfig.FingerprintType.SAFE
        "FULL" -> AppProtectionConfig.FingerprintType.FULL
        else -> throw InvalidConfigException("fingerprint")
    }

private fun ReadableMap.toDetectionConfig(path: String, innerName: String = "MalwarelyticsAndroidRaspDetectionConfig"): DetectionConfig {
    val exitUrl = stringOptAt("exitUrl")
    return when (stringAt("action", innerName)) {
        "NO_ACTION" -> DetectionConfig.NoAction
        "NOTIFY" -> DetectionConfig.Notify
        "EXIT" -> DetectionConfig.Exit(exitUrl)
        else -> throw InvalidConfigException("$path.action", innerName)
    }
}

private fun ReadableMap.toRootDetectionConfig(): RootDetectionConfig {
    val innerName: String = "MalwarelyticsAndroidRaspRootDetectionConfig"
    val exitUrl = stringOptAt("exitUrl")
    val minConfidence = floatOpAt("exitOnRootMinConfidence")
    return when (stringAt("action", innerName)) {
        "NO_ACTION" -> RootDetectionConfig.NoAction
        "NOTIFY" -> RootDetectionConfig.Notify
        "EXIT" -> {
            if (minConfidence != null) { 
                RootDetectionConfig.Exit(exitUrl, minConfidence)
            } else {
                RootDetectionConfig.Exit(exitUrl)
            }
        }
        else -> throw InvalidConfigException("root.action", innerName)
    }
}

private fun ReadableMap.toDebuggerDetectionConfig(): DebuggerDetectionConfig {
    val innerName: String = "MalwarelyticsAndroidRaspDebuggerDetectionConfig"
    val detectionConfig = toDetectionConfig("debugger", innerName)
    val builder = DebuggerDetectionConfig.Builder()
        .action(detectionConfig)

    stringArrayOptAt("debuggerTypes", "DebuggerType")?.let {array -> 
        builder.debuggerTypes(array.map { dt ->
            when (dt) {
                "JAVA" -> DebuggerType.JAVA
                "NATIVE" -> DebuggerType.NATIVE
                else -> throw InvalidConfigException("debugger.action", innerName)
            }
        })
    }
    return builder.build()
}

private fun ReadableMap.toRepackageDetectionConfig(): RepackageDetectionConfig {
    val innerName: String = "MalwarelyticsAndroidRaspRepackageDetectionConfig"
    val jsRepackaging = "MalwarelyticsAndroidRaspRepackagingDetectionConfig"
    val detectionConfig = toDetectionConfig("repackage", innerName)
    val builder = RepackageDetectionConfig.Builder()
        .action(detectionConfig)

    stringArrayOptAt("signatureHash", jsRepackaging)?.let { array ->
        builder.signatureHash(array.toList())
    }
    return builder.build()
}

private fun ReadableMap.toAdbDetectionConfig(): AdbDetectionConfig {
    val innerName: String = "MalwarelyticsAndroidRaspAdbDetectionConfig"
    val exitUrl = stringOptAt("exitUrl")
    return when (stringAt("action", innerName)) {
        "NOTIFY" -> AdbDetectionConfig.Notify
        "EXIT" -> AdbDetectionConfig.Exit(exitUrl)
        else -> throw InvalidConfigException("adb.action", innerName)
    }
}

private fun ReadableMap.toBlockConfig(path: String, innerName: String = "MalwarelyticsAndroidRaspBlockConfig"): BlockConfig {
    return when (stringAt("action", innerName)) {
        "NO_ACTION" -> BlockConfig.NoAction
        "BLOCK" -> BlockConfig.Block
        else -> throw InvalidConfigException("$path.action", innerName)
    }
}

private fun ReadableMap.toTapjackingBlockConfig(): TapjackingBlockConfig {
    val innerName: String = "MalwarelyticsAndroidRaspTapjackingBlockConfig"
    val jsAndroidApk = "AndroidApk"
    val blockConfig = toBlockConfig("tapjacking", innerName)
    val builder = TapjackingBlockConfig.Builder()
        .action(blockConfig)

    stringOptAt("blockSensitivity", innerName)?.let {
        try {
            builder.blockTapjackingSensitivity(ThreatIndex.valueOf(it))
        } catch (t: Throwable) {
            throw InvalidConfigException("blockSensitivity", innerName)
        }
    }
    boolOptAt("ignoreSystemApps", innerName)?.let { 
        builder.ignoreTapjackingSystemApps(it) 
    }
    mapArrayOptAt("allowedTapjackingApps", innerName, jsAndroidApk)?.let { array ->
        builder.allowedTapjackingApps(array.map {
            RaspConfig.ApkAllowlistItem(
                it.stringAt("packageName", jsAndroidApk),
                it.stringOptAt("signatureHash", jsAndroidApk)
            )
        })
    }
    return builder.build()
}

private fun ReadableMap.toScreenReaderBlockConfig(): ScreenReaderBlockConfig {
    val innerName: String = "MalwarelyticsAndroidRaspScreenReaderBlockConfig"
    val jsAndroidApk = "AndroidApk"
    val blockConfig = toBlockConfig("screenReader", innerName)
    val builder = ScreenReaderBlockConfig.Builder()
        .action(blockConfig)

    mapArrayOptAt("allowedScreenReaders", innerName, jsAndroidApk)?.let { array ->
        builder.allowedScreenReaders(array.map {
            RaspConfig.ApkAllowlistItem(
                it.stringAt("packageName", jsAndroidApk),
                it.stringOptAt("signatureHash", jsAndroidApk)
            )
        })
    }
    return builder.build()
}

private fun ReadableMap.toProcessNameConfig(): ProcessNameConfig {
    val innerName: String = "MalwarelyticsAndroidRaspProcessNameConfig"
    val customProcessName = stringOptAt("customProcessName")
    return when (stringAt("action", innerName)) {
        "NO_ACTION" -> ProcessNameConfig.NoAction
        "USE_STEALTHY" -> ProcessNameConfig.UseStealthy(customProcessName)
        else -> throw InvalidConfigException("processName.action", innerName)
    }
}

private fun ReadableMap.toSimpleDetectionConfig(path: String, innerName: String = "MalwarelyticsAndroidRaspSimpleDetectionConfig"): SimpleDetectionConfig {
    return when (stringAt("action", innerName)) {
        "NO_ACTION" -> SimpleDetectionConfig.NoAction
        "NOTIFY" -> SimpleDetectionConfig.Notify
        else -> throw InvalidConfigException("$path.action", innerName)
    }
}


private fun ReadableMap.toAppPresenceDetectionConfig(): AppPresenceDetectionConfig {
    val innerName: String = "MalwarelyticsAndroidRaspAppPresenceDetectionConfig"
    val jsNamedApkItem = "MalwarelyticsAndroidRaspNamedApkItem"
    val detectionConfig = toDetectionConfig("appPresence", innerName)
    val builder = AppPresenceDetectionConfig.Builder()
        .action(detectionConfig)

    mapArrayOptAt("remoteDesktopApps", innerName, jsNamedApkItem)?.let { array ->
        builder.remoteDesktopApps(array.map {
            AppPresenceDetectionConfig.NamedApkItem(
                it.stringAt("displayName", jsNamedApkItem),
                it.stringAt("packageName", jsNamedApkItem),
                it.stringOptAt("signatureHash", jsNamedApkItem)
            )
        })
    }
    return builder.build()
}
