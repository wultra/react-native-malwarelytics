//
// Copyright 2023 Wultra s.r.o.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.
//

package com.wultra.android.malwarelytics.reactnative

import android.content.Context
import com.facebook.react.bridge.ReadableMap
import com.wultra.android.antimalware.AntivirusConfig
import com.wultra.android.antimalware.ThreatIndex
import com.wultra.android.appprotection.AppProtectionConfig
import com.wultra.android.rasp.RaspConfig

/**
 * Create [AppProtectionConfig] from [ReadableMap].
 * @param context Android context
 * @param javaPackagePath Path to Java package.
 */
fun ReadableMap.toAppProtectionConfig(context: Context, javaPackagePath: String): AppProtectionConfig {
    // RASP
    val raspBuilder = RaspConfig.Builder()
    mapOptAt("android.rasp")?.apply {
        val jsObj = "MalwarelyticsAndroidRaspConfig"
        val jsAndroidApk = "AndroidApk"
        val jsTapjacking = "MalwarelyticsAndroidRaspTapjackingConfig"
        val jsRepackaging = "MalwarelyticsAndroidRaspRepackagingDetectionConfig"
        val jsScreenReaders = "MalwarelyticsAndroidRaspScreenReadersConfig"
        withRaspDetectionConfig("emulator", jsObj) { config, _ ->
            raspBuilder.checkEmulator(config.on)
            raspBuilder.exitOnEmulator(config.exit)
            config.url?.let { raspBuilder.exitOnEmulatorUrl(it) }
        }
        withRaspDetectionConfig("root", jsObj, "MalwarelyticsAndroidRaspRootDetectionConfig") { config, map ->
            raspBuilder.checkRoot(config.on)
            raspBuilder.exitOnRoot(config.exit)
            config.url?.let { raspBuilder.exitOnRootUrl(it) }
            map.floatOpAt("exitOnRootMinConfidence")?.let { raspBuilder.exitOnRootMinConfidence(it) }
        }
        withRaspDetectionConfig("httpProxy", jsObj) { config, _ ->
            raspBuilder.checkHttpProxy(config.on)
            raspBuilder.exitOnHttpProxy(config.exit)
            config.url?.let { raspBuilder.exitOnHttpProxyUrl(it) }
        }
        withRaspDetectionConfig("debugger", jsObj) { config, _ ->
            raspBuilder.checkDebugger(config.on)
            raspBuilder.exitOnDebugger(config.exit)
            config.url?.let { raspBuilder.exitOnDebuggerUrl(it) }
        }
        withRaspDetectionConfig("repackage", jsObj, jsRepackaging) { config, map ->
            raspBuilder.checkRepackaging(config.on)
            raspBuilder.exitOnRepackaging(config.exit)
            config.url?.let { raspBuilder.exitOnRepackagingUrl(it) }
            map.stringArrayOptAt("signatureHash", jsRepackaging)?.let { array ->
                raspBuilder.signatureHash(*array)
            }
        }
        withRaspDetectionConfig("vpn", jsObj) { config, _ ->
            raspBuilder.checkVpn(config.on)
            raspBuilder.exitOnVpn(config.exit)
            config.url?.let { raspBuilder.exitOnVpnUrl(it) }
        }
        withRaspDetectionConfig("adb", jsObj) { config, _ ->
            raspBuilder.exitOnAdbEnabled(config.exit)
            config.url?.let { raspBuilder.exitOnAdbEnabledUrl(it) }
        }
        mapOptAt("tapjacking", jsObj)?.let {
            it.boolOptAt("block", jsTapjacking)?.let { raspBuilder.blockTapjacking(it) }
            it.stringOptAt("blockSensitivity", jsTapjacking)?.let {
                try {
                    raspBuilder.blockTapjackingSensitivity(ThreatIndex.valueOf(it))
                } catch (t: Throwable) {
                    throw InvalidConfigException("blockSensitivity", jsTapjacking)
                }
            }
            it.boolOptAt("ignoreSystemApps", jsTapjacking)?.let { raspBuilder.ignoreTapjackingSystemApps(it) }
        }
        withRaspDetectionConfig("screenSharing", jsObj) { config, _ ->
            raspBuilder.checkScreenSharing(config.on)
            raspBuilder.exitOnScreenSharing(config.exit)
            config.url?.let { raspBuilder.exitOnScreenSharingUrl(it) }
        }
        mapOptAt("screenReaders", jsObj)?.let {
            it.boolOptAt("block", jsScreenReaders)?.let { raspBuilder.blockScreenReaders(it) }
            it.mapArrayOptAt("allowedScreenReaders", jsObj, jsAndroidApk)?.let { array ->
                raspBuilder.allowedScreenReaders(array.map {
                    RaspConfig.ApkAllowlistItem(
                        it.stringAt("packageName", jsAndroidApk),
                        it.stringOptAt("signatureHash", jsAndroidApk)
                    )
                })
            }
        }
        boolOptAt("blockScreenshots", jsObj)?.let { raspBuilder.blockScreenshots(it) }
        stringOptAt("customProcessName", jsObj)?.let { raspBuilder.customProcessName(it) }
        boolOptAt("useStealthyProcessName", jsObj)?.let { raspBuilder.useStealthyProcessName(it) }
    }
    val raspConfig = raspBuilder.build()

    // Antivirus

    val avBuilder = AntivirusConfig.Builder()
    val spBuilder = AntivirusConfig.SmartProtectionConfig.Builder()
    val tmBuilder = AntivirusConfig.ThreatMitigationUIConfig.Builder()
    mapOptAt("android.antivirus")?.apply {
        val jsObj = "MalwarelyticsAndroidAntivirusConfig"
        boolOptAt("disable", jsObj)?.let { avBuilder.enableAntivirus(!it) }
        boolOptAt("enableSilentMode", jsObj)?.let { spBuilder.silentModeEnabled(it) }
        intOptAt("onlineCheckIntervalHours", jsObj)?.let { spBuilder.smartProtectionIntervalHours(it) }
        boolOptAt("updateOnInitialize", jsObj)?.let { spBuilder.performInitialFirstUpdate(it) }
    }

    stringOptAt("android.languageCode")?.let { tmBuilder.customLocalization(it) }
    val uiConfig = getMalwarelyticsUiConfig(javaPackagePath)
    uiConfig.theme?.let { tmBuilder.screenTheme(it) }
    uiConfig.notificationSmallIcon?.let { tmBuilder.notificationSmallIcon(it) }
    uiConfig.notificationChannelId?.let { tmBuilder.notificationChannelId(it) }
    uiConfig.screenSettingsIcon?.let { tmBuilder.screenSettingsIcon(it) }
    uiConfig.screenDeleteIcon?.let { tmBuilder.screenDeleteIcon(it) }

    val avConfig = avBuilder
        .threatMitigationUIConfig(tmBuilder.build())
        .smartProtectionConfig(spBuilder.build())
        .build()

    // Customer grouping

    val cgBuilder = AppProtectionConfig.CustomerGroupingConfig.Builder()
    mapOptAt("android.customerGrouping")?.apply {
        val jsObj = "MalwarelyticsAndroidCustomerGroupingConfig"
        stringOptAt("sourcePackageName", jsObj)?.let { cgBuilder.sourcePackageName(it) }
        stringOptAt("appPackageName", jsObj)?.let { cgBuilder.appPackageName(it) }
        stringOptAt("audienceGroupId", jsObj)?.let { cgBuilder.audienceGroupId(it) }
    }
    val cgConfig = cgBuilder.build()

    // Main configuration

    val builder = AppProtectionConfig.Builder(context)
    mapOptAt("android.service")?.apply {
        val jsObj = "MalwarelyticsServiceConfig"
        stringAt("username", jsObj).let { builder.apiUsername(it) }
        stringAt("password", jsObj).let { builder.apiPassword(it) }
        stringOptAt("signaturePublicKey", jsObj)?.let { builder.apiSignaturePublicKey(it) }
    }
    mapOptAt("clientIdentification")?.apply {
        val jsObj = "MalwarelyticsClientIdentification"
        stringOptAt("clientId", jsObj)?.let { builder.clientAppUserId(it) }
        stringOptAt("deviceId", jsObj)?.let { builder.clientAppDeviceId(it) }
    }
    val jsServiceConf = "MalwarelyticsServiceConfig"
    var environmentConfig = stringOptAt("android.service.environment", jsServiceConf)?.toEnvironmentConfiguration(jsServiceConf)
    if (environmentConfig == null) {
        environmentConfig = stringOptAt("environment", null)?.toEnvironmentConfiguration(null)
    }
    environmentConfig?.let { builder.environment(it) }

    // Final config
    return builder
        .antivirusConfig(avConfig)
        .raspConfig(raspConfig)
        .customerGroupingConfig(cgConfig)
        .build()
}

private fun String.toEnvironmentConfiguration(objName: String?): AppProtectionConfig.EnvironmentConfiguration =
    when (this) {
        "PRODUCTION" -> AppProtectionConfig.EnvironmentConfiguration.PRODUCTION_ENVIRONMENT
        "TEST" -> AppProtectionConfig.EnvironmentConfiguration.TEST_ENVIRONMENT
        else -> throw InvalidConfigException("environment", objName)
    }

private data class RaspDetectionConfig(val on: Boolean, val exit: Boolean, val url: String?)

private fun ReadableMap.withRaspDetectionConfig(path: String, objName: String? = null, innerName: String = "MalwarelyticsAndroidRaspDetectionConfig", action: (config: RaspDetectionConfig, map: ReadableMap) -> Unit) {
    mapOptAt(path, objName)?.apply {
        val exitUrl = stringOptAt("exitUrl")
        val config = when (stringAt("action", innerName)) {
            "NO_ACTION" -> RaspDetectionConfig(on = false, exit = false, exitUrl)
            "NOTIFY" -> RaspDetectionConfig(on = true, exit = false, exitUrl)
            "EXIT" -> RaspDetectionConfig(on = true, exit = true, exitUrl)
            else -> throw InvalidConfigException("$path.action", innerName)
        }
        action(config, this)
    }
}
