//
// Copyright 2023 Wultra s.r.o.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.
//

package com.wultra.android.malwarelytics.reactnative

import com.facebook.react.bridge.*

interface RnConvertibleError {
    fun toErrorInfo(): ErrorInfo
}

fun Throwable.reject(promise: Promise) {
    val info: ErrorInfo =
        when (this) {
            is RnConvertibleError -> this.toErrorInfo()
            is java.lang.IllegalArgumentException -> ErrorInfo(ErrorCode.INVALID_PARAM, message?:"Invalid parameter provided", this)
            is java.lang.IllegalStateException -> ErrorInfo(ErrorCode.WRONG_STATE, message?:"Wrong state", this)
            // TODO: add other possible errors
            else -> ErrorInfo(ErrorCode.GENERIC_ERROR, "Unknown error", this)
        }
    promise.reject(info.code.name, info.message, info.cause)
}

fun Iterable<String>.toJs(): WritableArray {
    val result = Arguments.createArray()
    this.forEach { result.pushString(it) }
    return result
}

fun WritableMap.put(key: String, value: Iterable<String>?) = value?.let { this.putArray(key, it.toJs()) }
fun WritableMap.put(key: String, value: ReadableMap?) = value?.let { this.putMap(key, it) }
fun WritableMap.put(key: String, value: Int?) = value?.let { this.putInt(key, it) }
fun WritableMap.put(key: String, value: Boolean?) = value?.let { this.putBoolean(key, it) }
fun WritableMap.put(key: String, value: String?) = value?.let { this.putString(key, it) }
fun WritableMap.put(key: String, value: Float?) = value?.let { this.putDouble(key, it.toDouble()) }
fun WritableMap.put(key: String, value: Double?) = value?.let { this.putDouble(key, it) }
fun WritableMap.putAny(key: String, value: Any?) {
    when (value) {
        is String -> putString(key, value)
        is Boolean -> putBoolean(key, value)
        is ReadableMap -> putMap(key, value)
        is ReadableArray -> putArray(key, value)
        is Float -> putDouble(key, value.toDouble())
        is Double -> putDouble(key, value)
        is Int -> putInt(key, value)
    }
}

fun simpleWritableMap(key: String, value: Any?): WritableMap {
    val m = Arguments.createMap()
    m.putAny(key, value)
    return m
}

fun ReadableMap.objectAt(path: String, objName: String? = null, required: Boolean = false, type: ReadableType? = null): Dynamic? {
    var dict = this
    var result: Dynamic? = null
    val components = path.split(".")
    for (i in 0 until components.size) {
        val isLastKey = i == components.size - 1
        val key = components[i]

        result = if (dict.hasKey(key)) {
            dict.getDynamic(key)
        } else {
            break   // There's no such key
        }
        if (!isLastKey) {
            if (result.type == ReadableType.Map) {
                dict = result.asMap()
                result = null
            } else {
                // Object acquired in the middle of path is not a dictionary
                throw InvalidConfigException(path, objName)
            }
        }
    }
    if ((result == null || result.isNull) && required) {
        // Result is null and is expected
        throw MissingConfigException(path, objName)
    }
    if (type != null && result != null && result.type != type) {
        // Result type is specified
        throw InvalidConfigException(path, objName)
    }
    return result
}

fun ReadableMap.hasObjectAt(path: String): Boolean {
    return try {
        val obj = objectAt(path)
        obj != null && !obj.isNull
    } catch (t: Throwable) {
        false
    }
}

fun ReadableMap.boolAt(path: String, objName: String? = null): Boolean {
    return objectAt(path, objName, true, ReadableType.Boolean)?.asBoolean() ?: throw MissingConfigException(path, objName)
}

fun ReadableMap.boolOptAt(path: String, objName: String? = null): Boolean? {
    return objectAt(path, objName, false, ReadableType.Boolean)?.asBoolean()
}

fun ReadableMap.intOptAt(path: String, objName: String? = null): Int? {
    return objectAt(path, objName, false, ReadableType.Number)?.asInt()
}

fun ReadableMap.floatOpAt(path: String, objName: String? = null): Float? {
    return objectAt(path, objName, false, ReadableType.Number)?.asDouble()?.toFloat()
}

fun ReadableMap.stringAt(path: String, objName: String? = null): String {
    return objectAt(path, objName, true, ReadableType.String)?.asString() ?: throw MissingConfigException(path, objName)
}

fun ReadableMap.stringOptAt(path: String, objName: String? = null): String? {
    return objectAt(path, objName, false, ReadableType.String)?.asString()
}

fun ReadableMap.mapAt(path: String, objName: String? = null, required: Boolean = true): ReadableMap {
    return objectAt(path, objName, required, ReadableType.Map)?.asMap() ?: Arguments.createMap()
}

fun ReadableMap.stringArrayOptAt(path: String, objName: String? = null): Array<String>? {
    return objectAt(path, objName, false, ReadableType.Array)?.asArray()?.let { a ->
        Array(a.size()) { index ->
            if (a.getType(index) == ReadableType.String) {
                a.getString(index)
            } else {
                throw InvalidConfigException(path, objName)
            }
        }
    }
}

fun ReadableMap.mapArrayOptAt(path: String, objName: String? = null, innerObjName: String? = null): Array<ReadableMap>? {
    return objectAt(path, objName, false, ReadableType.Array)?.asArray()?.let { a ->
        Array(a.size()) { index ->
            if (a.getType(index) == ReadableType.Map) {
                a.getMap(index)
            } else {
                throw InvalidConfigException(path, innerObjName)
            }
        }
    }
}

fun ReadableMap.mapOptAt(path: String, objName: String? = null): ReadableMap? {
    return try {
        objectAt(path, objName, false, ReadableType.Map)?.asMap()
    } catch (t: Throwable) {
        null
    }
}
