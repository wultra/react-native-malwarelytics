//
// Copyright 2023 Wultra s.r.o.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.
//

package com.wultra.android.malwarelytics.reactnative

import com.facebook.react.bridge.*

// -------------------------------------------------------------------------------------------------
// Exceptions

/**
 * Interface allows to convert object into [ErrorInfo].
 */
interface RnConvertibleError {
    /**
     * Convert object to [ErrorInfo].
     */
    fun toErrorInfo(): ErrorInfo
}

/**
 * Reject exception with using given promise.
 * @param promise [Promise] to reject.
 */
fun Throwable.reject(promise: Promise) {
    val info: ErrorInfo =
        when (this) {
            is RnConvertibleError -> this.toErrorInfo()
            is java.lang.IllegalArgumentException -> ErrorInfo(ErrorCode.INVALID_PARAM, message ?: "Invalid parameter provided", this)
            is java.lang.IllegalStateException -> ErrorInfo(ErrorCode.WRONG_STATE, message ?: "Wrong state", this)
            // TODO: add other possible errors
            else -> ErrorInfo(ErrorCode.GENERIC_ERROR, "Unknown error", this)
        }
    promise.reject(info.code.name, info.message, info.cause)
}

/**
 * Report [Result] back to [Promise]. The function handles success and failure states internally.
 */
fun <T> Result<T>.report(promise: Promise) {
    onSuccess { promise.resolve(it) }
    onFailure { it.reject(promise) }
}

// -------------------------------------------------------------------------------------------------
// ReadableArray


/**
 * Convert iterable collection of strings into [ReadableArray].
 */
fun Iterable<String>.toJs(): ReadableArray {
    val result = Arguments.createArray()
    this.forEach { result.pushString(it) }
    return result
}

/**
 * Convert iterable collection of type `T` into [ReadableArray]. The conversion is implemented
 * in the provided mapping function. The returned type `M` must be one of supported by React Native
 * runtime (e.g. [ReadableMap], [ReadableArray], `Double`, `Boolean`, etc...)
 */
fun <T, M> Iterable<T>.toJs(mappingFn: (item: T) -> M?): ReadableArray {
    val array = Arguments.createArray()
    this.forEach {
        when (val mapped = mappingFn(it)) {
            is String -> array.pushString(mapped)
            is ReadableMap -> array.pushMap(mapped)
            is ReadableArray -> array.pushArray(mapped)
            is Double -> array.pushDouble(mapped)
            is Boolean -> array.pushBoolean(mapped)
            is Int -> array.pushInt(mapped)
            null -> array.pushNull()
        }
    }
    return array
}

// -------------------------------------------------------------------------------------------------
// WritableMap
//
// All the following functions implements putting of optional values into `WritableMap`. Each of the
// function return `this`, so the method chaining can be used.
//

fun WritableMap.put(key: String, value: Iterable<String>?): WritableMap {
    value?.let { this.putArray(key, it.toJs()) }
    return this
}
fun WritableMap.put(key: String, value: ReadableMap?): WritableMap {
    value?.let { this.putMap(key, it) }
    return this
}
fun WritableMap.put(key: String, value: Int?): WritableMap {
    value?.let { this.putInt(key, it) }
    return this
}
fun WritableMap.put(key: String, value: Boolean?): WritableMap {
    value?.let { this.putBoolean(key, it) }
    return this
}
fun WritableMap.put(key: String, value: CharSequence?): WritableMap {
    value?.let { this.putString(key, it.toString()) }
    return this
}
fun WritableMap.put(key: String, value: Float?): WritableMap {
    value?.let { this.putDouble(key, it.toDouble()) }
    return this
}
fun WritableMap.put(key: String, value: Double?): WritableMap {
    value?.let { this.putDouble(key, it) }
    return this
}
fun WritableMap.put(key: String, value: ReadableArray?): WritableMap {
    value?.let { this.putArray(key, it) }
    return this
}

/**
 * Function put arbitrary value into writable map. The value type must be supported by [WritableMap]
 * object, otherwise the value is ignored.
 */
fun WritableMap.putAny(key: String, value: Any?): WritableMap {
    when (value) {
        is String -> putString(key, value)
        is Boolean -> putBoolean(key, value)
        is ReadableMap -> putMap(key, value)
        is ReadableArray -> putArray(key, value)
        is Float -> putDouble(key, value.toDouble())
        is Double -> putDouble(key, value)
        is Int -> putInt(key, value)
    }
    return this
}

/**
 * Create simple [WritableMap] for key and any value.
 */
fun simpleWritableMap(key: String, value: Any?): WritableMap {
    val m = Arguments.createMap()
    m.putAny(key, value)
    return m
}

// -------------------------------------------------------------------------------------------------
// ReadableMap
//
// The following list of functions simplifies getting values from the ReadableMap. You can use
// dot-noted path to extract values stored deeper in the map structure.
//

/**
 * Extract object from the map.
 *
 * @param path Path to object. You can use simple key, or dot-noted path (e.g. "android.service")
 * @param objName Optional configuration object used for exception if something's wrong.
 * @param required If object at given path is required.
 * @param type If [ReadableType] provided, then specifying expected type of object at given path.
 *
 * @return [Dynamic] type that allows later conversion to native type.
 */
fun ReadableMap.objectAt(path: String, objName: String? = null, required: Boolean = false, type: ReadableType? = null): Dynamic? {
    var dict = this
    var result: Dynamic? = null
    val components = path.split(".")
    for (i in 0 until components.size) {
        val isLastKey = i == components.size - 1
        val key = components[i]

        result = if (dict.hasKey(key)) {
            dict.getDynamic(key)
        } else {
            break   // There's no such key
        }
        if (!isLastKey) {
            if (result.type == ReadableType.Map) {
                dict = result.asMap()
                result = null
            } else {
                // Object acquired in the middle of path is not a dictionary
                throw InvalidConfigException(path, objName)
            }
        }
    }
    if ((result == null || result.isNull) && required) {
        // Result is null and is expected
        throw MissingConfigException(path, objName)
    }
    if (type != null && result != null && result.type != type) {
        // Result type is specified
        throw InvalidConfigException(path, objName)
    }
    return result
}

/**
 * Test whether map contains object at given path.
 */
fun ReadableMap.hasObjectAt(path: String): Boolean {
    return try {
        val obj = objectAt(path)
        obj != null && !obj.isNull
    } catch (t: Throwable) {
        false
    }
}

/**
 * Return required boolean at given path.
 */
fun ReadableMap.boolAt(path: String, objName: String? = null): Boolean {
    return objectAt(path, objName, true, ReadableType.Boolean)?.asBoolean() ?: throw MissingConfigException(path, objName)
}

/**
 * Return optional boolean at given path.
 */
fun ReadableMap.boolOptAt(path: String, objName: String? = null): Boolean? {
    return objectAt(path, objName, false, ReadableType.Boolean)?.asBoolean()
}

/**
 * Return optional integer at given path.
 */
fun ReadableMap.intOptAt(path: String, objName: String? = null): Int? {
    return objectAt(path, objName, false, ReadableType.Number)?.asInt()
}

/**
 * Return optional float at given path.
 */
fun ReadableMap.floatOpAt(path: String, objName: String? = null): Float? {
    return objectAt(path, objName, false, ReadableType.Number)?.asDouble()?.toFloat()
}

/**
 * Return required string at given path.
 */
fun ReadableMap.stringAt(path: String, objName: String? = null): String {
    return objectAt(path, objName, true, ReadableType.String)?.asString() ?: throw MissingConfigException(path, objName)
}

/**
 * Return optional string at given path.
 */
fun ReadableMap.stringOptAt(path: String, objName: String? = null): String? {
    return objectAt(path, objName, false, ReadableType.String)?.asString()
}

/**
 * Return map at given path. If map is not required and is not available, then returns empty map.
 */
fun ReadableMap.mapAt(path: String, objName: String? = null, required: Boolean = true): ReadableMap {
    return objectAt(path, objName, required, ReadableType.Map)?.asMap() ?: Arguments.createMap()
}

/**
 * Return optional array of strings at given path.
 */
fun ReadableMap.stringArrayOptAt(path: String, objName: String? = null): Array<String>? {
    return objectAt(path, objName, false, ReadableType.Array)?.asArray()?.let { a ->
        Array(a.size()) { index ->
            if (a.getType(index) == ReadableType.String) {
                a.getString(index)
            } else {
                throw InvalidConfigException(path, objName)
            }
        }
    }
}

/**
 * Return optional array of [ReadableMap] object at given path.
 */
fun ReadableMap.mapArrayOptAt(path: String, objName: String? = null, innerObjName: String? = null): Array<ReadableMap>? {
    return objectAt(path, objName, false, ReadableType.Array)?.asArray()?.let { a ->
        Array(a.size()) { index ->
            if (a.getType(index) == ReadableType.Map) {
                a.getMap(index)
            } else {
                throw InvalidConfigException(path, innerObjName)
            }
        }
    }
}

/**
 * Return optional map at given path.
 */
fun ReadableMap.mapOptAt(path: String, objName: String? = null): ReadableMap? {
    return try {
        objectAt(path, objName, false, ReadableType.Map)?.asMap()
    } catch (t: Throwable) {
        null
    }
}
