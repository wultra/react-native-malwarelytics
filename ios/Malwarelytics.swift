//
// Copyright 2023 Wultra s.r.o.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.
//

import Foundation
import Dispatch
import AppProtection

@objc(Malwarelytics)
class Malwarelytics: RCTEventEmitter, RCTInitializing {
    
    // MARK: - RN integration & State
    
    /// Module's state
    enum State {
        case shutdown
        case pendingInit
        case ready
        case pendingShutdown
        
        var asString: String {
            switch self {
            case .shutdown:         return "SHUTDOWN"
            case .pendingInit:      return "PENDING_INIT"
            case .ready:            return "READY"
            case .pendingShutdown:  return "PENDING_SHUTDOWN"
            }
        }
    }
    
    /// Module's initialization result
    enum InitResult {
        case success
        case permanentOffline
        
        var asString: String {
            switch self {
            case .success:          return "SUCCESS"
            case .permanentOffline: return "PERMANENT_OFFLINE_MODE"
            }
        }
    }
    
    /// Event type
    enum Event {
        case state
        case rasp
        
        var asString: String {
            switch self {
            case .state:    return "Malwarelytics.STATE"
            case .rasp:     return "Malwarelytics.RASP"
            }
        }
    }
    
    
    /// Current state of the module
    private var state = State.shutdown
    
    /// Current initialization result.
    private var initResult: InitResult?
    
    /// A working queue that
    private var workingQueue: DispatchQueue!
    
    func initialize() {
        // Called by RN, when this module is being initialized
        workingQueue = DispatchQueue(label: "MalwarelyticsRNBridge")
    }
    
    override func invalidate() {
        super.invalidate()
        serviceInstance?.rasp.removeDelegate(self)
        serviceInstance?.release()
        serviceInstance = nil
        state = .shutdown
    }
    
    // MARK: - Events
    
    override func supportedEvents() -> [String]! {
        return [ Event.state, .rasp].map { $0.asString }
    }
    
    func sendEvent(_ event: Event, object: Encodable) {
        do {
            sendEvent(event, body: try object.toJsObject())
        } catch {
            // TODO: dump error
        }        
    }
    
    func sendEvent(_ event: Event, body: Any, checkState: Bool = true) {
        workingQueue.async {
            if checkState && self.state != .ready {
                // Ignore the event if "ready" state is expected.
                return
            }
            self.sendEvent(withName: event.asString, body: body)
        }
    }
    
    
    // MARK: - Exported functions
    
    @objc(initialize:resolver:rejecter:)
    func initialize(_ config: Dictionary<String, Any>?, resolve: @escaping RCTPromiseResolveBlock, reject: @escaping RCTPromiseRejectBlock) -> Void {
        resolveOnQueue(resolve: resolve, reject: reject, expectedState: .shutdown) {
            guard let config = config else {
                throw ModuleError.missingParam(paramName: "configuration")
            }
            let serviceConfig = try AppProtectionConfig.fromDictionary(config)
            self.startService(config: serviceConfig)
            let result = config.hasObjectAt("apple.service") ? InitResult.success : .permanentOffline
            self.initResult = result
            return result.asString
        }
    }
    
    @objc(shutdown:rejecter:)
    func shutdown(_ resolve: @escaping RCTPromiseResolveBlock, reject: @escaping RCTPromiseRejectBlock) -> Void {
        resolveOnQueue(resolve: resolve, reject: reject) {
            self.stopService()
        }
    }
    
    private struct StateWithResult: Encodable {
        let state: String
        let result: String?
    }
    
    @objc(getState:rejecter:)
    func getModuleState(_ resolve: @escaping RCTPromiseResolveBlock, reject: @escaping RCTPromiseRejectBlock) -> Void {
        resolveOnQueue(resolve: resolve, reject: reject, expectedState: nil) {
            return try StateWithResult(state: self.state.asString, result: self.initResult?.asString).toJsObject()
        }
    }
    
    @objc(getSupportedEvents:rejecter:)
    func getSupportedEvents(_ resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) -> Void {
        resolve(self.supportedEvents())
    }
    
    @objc(getRaspInfo:resolver:rejecter:)
    func getRaspInfo(_ message: String?, resolve: @escaping RCTPromiseResolveBlock, reject: @escaping RCTPromiseRejectBlock) -> Void {
        resolveOnQueue(resolve: resolve, reject: reject) {
            guard let message = message else {
                throw ModuleError.missingParam(paramName: "message")
            }
            return try self.getRaspInfo(service: self.service, infoType: message).toJsObject()
        }
    }
    
    @objc(setClientId:resolver:rejecter:)
    func setClientId(_ clientId: String?, resolve: @escaping RCTPromiseResolveBlock, reject: @escaping RCTPromiseRejectBlock) -> Void {
        resolveOnQueue(resolve: resolve, reject: reject) {
            try self.service.clientIdentification.userId = clientId
        }
    }
    
    @objc(setDeviceId:resolver:rejecter:)
    func setDeviceId(_ deviceId: String?, resolve: @escaping RCTPromiseResolveBlock, reject: @escaping RCTPromiseRejectBlock) -> Void {
        resolveOnQueue(resolve: resolve, reject: reject) {
            try self.service.clientIdentification.deviceId = deviceId
        }
    }
    
    @objc(getAvUserId:rejecter:)
    func getAvUserId(_ resolve: @escaping RCTPromiseResolveBlock, reject: @escaping RCTPromiseRejectBlock) -> Void {
        resolveOnQueue(resolve: resolve, reject: reject) {
            try self.service.avUid
        }
    }
    
    // MARK: - Native service
    
    private var service: AppProtectionService {
        get throws {
            guard let service = serviceInstance else {
                throw ModuleError.genericError(message: "Service is required, but it's not available")
            }
            return service
        }
    }
    
    private var serviceInstance: AppProtectionService?
    
    private func startService(config: AppProtectionConfig) {
        self.changeState(.pendingInit)
        let service = AppProtectionService(config: config)
        service.rasp.addDelegate(self)
        self.serviceInstance = service
        self.changeState(.ready)
    }
    
    private func stopService() {
        self.changeState(.pendingShutdown)
        serviceInstance?.rasp.removeDelegate(self)
        serviceInstance?.release()
        serviceInstance = nil
        initResult = nil
        self.changeState(.shutdown)
    }
    
    // MARK: - Internal functions
    
    /// Function execute block on internal working queue and handle potential failures during the block execution. The value returned
    /// from the block is then used to resolve the JS promise.
    /// - Parameters:
    ///   - resolve: Resolve block.
    ///   - reject: Reject block.
    ///   - expectedState: If provided, then module must be in the expected state.
    ///   - block: Block to execute on working queue.
    private func resolveOnQueue<T>(resolve: @escaping RCTPromiseResolveBlock, reject: @escaping RCTPromiseRejectBlock, expectedState: State? = .ready, block: @escaping () throws -> T) {
        workingQueue.async {
            do {
                if let expectedState = expectedState {
                    guard expectedState == self.state else {
                        throw ModuleError.wrongState(current: self.state, expected: expectedState)
                    }
                }
                let result = try block()
                resolve(result)
            } catch {
                error.report(to: reject)
            }
        }
    }
    
    /// Function changes internal state of the module and notifies all state observers.
    /// - Parameter newState: New module's state.
    private func changeState(_ newState: State) {
        self.state = newState
        self.sendEvent(.state, body: newState.asString as NSString, checkState: false)
    }
}
