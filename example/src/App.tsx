//
// Copyright 2023 Wultra s.r.o.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.
//

import * as React from 'react';

import { StyleSheet, View, Text, Appearance, NativeEventSubscription, SafeAreaView, Button, Platform } from 'react-native';
import { ApkThreat, EmulatorInfo, HttpProxyInfo, Malwarelytics, MalwarelyticsRaspListener, MalwarelyticsState, MalwarelyticsStateListener, RepackagingInfo, ScreenSharingInfo, SystemIntegrityInfo, TapjackingInfo } from 'react-native-malwarelytics';
import { defaultMalwarelyticsConfig } from './Config';

function AppLog(message: string) {
  console.log(`${Platform.OS}: ${message}`)
}
function AppErr(message: string) {
  console.error(`${Platform.OS}: ${message}`)
}
function AppWarn(message: string) {
  console.warn(`${Platform.OS}: ${message}`)
}

interface AppState {
  isDark: boolean
  moduleState: MalwarelyticsState
  raspInfo: string | undefined
  avSupported: boolean
  avState: string | undefined
}

// const Separator = () => (
//   <View style={styles.separator} />
// );

class App extends React.Component<{}, AppState> implements MalwarelyticsStateListener, MalwarelyticsRaspListener {
  state = {
    isDark: Appearance.getColorScheme() === 'dark',
    moduleState: 'SHUTDOWN' as MalwarelyticsState,
    raspInfo: undefined,
    avSupported: Malwarelytics.sharedInstance.antivirus.isSupported,
    avState: undefined
  }
  
  subscription?: NativeEventSubscription

  componentDidMount() {
    // Register for service's events
    this.service.rasp.setRaspListener(this)
    // This is optional, because your application typically don't need 
    // to listen to the state changes. We're using this only for 
    // the debugging purposes.
    this.service.setStateListener(this)
    // Update UI depending on actual state of module
    this.service.getState().then((state) => {
      AppLog(`Initial state is ${state}`)
      this.setState({ moduleState: state})
      if (state == 'READY') {
        this.populateModuleDetails()
      }
    })
    // Patch appearance
    this.subscription = Appearance.addChangeListener((_preferences) => {
      this.setState({isDark: Appearance.getColorScheme() === 'dark'})
    })
  }

  componentWillUnmount() {
    this.subscription?.remove()
  }

  render(): React.ReactNode {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.container}>
          <Text style={this.state.isDark ? styles.progressTextDark : styles.progressTextLight}>State: {this.stateWithResult}</Text>
        </View>
        <View style={styles.container}>
          <Text style={this.state.isDark ? styles.progressTextDark : styles.progressTextLight}>RASP: {this.state.raspInfo ?? 'N/A'}</Text>
        </View>
        <View style={styles.container}>
          <Text style={this.state.isDark ? styles.progressTextDark : styles.progressTextLight}>AV: {this.state.avState ?? 'N/A'}</Text>
        </View>
        { this.state.avSupported && this.state.moduleState == 'READY' ? 
            <Button title="SmartProtection" onPress={() => this.triggerSmartProtection() } /> :
            ""
        }
        { this.state.moduleState === "READY" ?
            <View style={styles.fixToText}>
              <Button title="Shutdown" onPress={() => this.malwarelyticsShutdown() } />
              <Button title="Refresh" onPress={() => this.populateModuleDetails() } />
            </View> : this.state.moduleState == "SHUTDOWN" ?
            <View style={styles.fixToText}>
              <Button title="Initialize" onPress={() => this.malwarelyticsInit() } />
            </View> :
            <View style={styles.fixToText}>
              <Button title="Please wait" />
            </View>
        }

      </SafeAreaView>
    )
  }

  service: Malwarelytics = Malwarelytics.sharedInstance

  // Initialization

  async malwarelyticsInit() {
    try {
      if (await this.service.isInitialized()) {
        AppWarn('Malwarelytics is already initialized')
        return
      }
      AppLog("Going to initialize..")
      const result = await this.service.initialize(defaultMalwarelyticsConfig())
      AppLog(`Module is now initialized with result ${result}`)
    } catch (error) {
      AppErr(`Exception while init': ${JSON.stringify(error)}`)
    }
  }
  
  async malwarelyticsShutdown() {
    try {
      if (!await this.service.isInitialized()) {
        AppWarn('Malwarelytics is already off')
        return
      }
      AppLog("Going to shutdown...")
      await this.service.shutdown()
      this.service.rasp.removeRaspListener()
      AppLog("Module is now off")
    } catch (error) {
      AppErr(`Exception while shutdown: ${JSON.stringify(error)}`)
    }
  }

  async triggerSmartProtection() {
    try {
      if (!await this.service.isInitialized()) {
        return
      }
      if (await this.service.antivirus.isSmartProtectionTriggered()) {
        AppLog('SmartProtection evaluation is alrady triggered.')
        return
      } else {
        AppLog('Triggering SmartProtection evaluation.')
      }
      const result = await this.service.antivirus.triggerSmartProtection(true)  
      AppLog(`Smarpt Protection result: ${JSON.stringify(result)}`)
    } catch (error) {
      AppErr(`Smart protection failed: ${JSON.stringify(error)}`)
    }
  }

  async populateRaspState(): Promise<string> {
    try {
      if (!await this.service.isInitialized()) {
        return "N/A"
      }
      const rasp = this.service.rasp
      var result = `Debugger = ${await rasp.isDebuggerConnected()}`
      const emulator = await rasp.isRunningInEmulator()
      result += `, Emulator = ${emulator}`
      if (emulator) {
        result += ` ${JSON.stringify(await rasp.getEmulatorInfo())}`
      }    
      result += `, Repackaging = ${await rasp.getRepackagingInfo()}`
      result += `, Proxy = ${JSON.stringify(await rasp.getHttpProxyInfo())}`
      result += `, ScreenSharing = ${JSON.stringify(await rasp.getScreenSharingInfo())}`
      result += `, VPN = ${await rasp.isVpnActive()}`
      
      if (Platform.OS == 'ios') {
        // iOS specific
        result += `, R-E-Tools = ${await rasp.isReverseEngineeringToolsPresent()}`
        result += `, SysPasscode = ${await rasp.isSystemPasscodeEnabled()}`
        result += `, SysBiometry = ${await rasp.isSystemBiometryEnabled()}`
      } else {
        // Android specific
        result += `, ADB = ${await rasp.getAdbStatus()}`
        result += `, Tapjacking = ${JSON.stringify(await rasp.getTapjackingInfo())}`
      }
      return result  
    } catch (error) {
      return `Exception: ${JSON.stringify(error)}`
    }
  }

  async populateAntivirusInfo(): Promise<string> {
    try {
      if (!await this.service.isInitialized()) {
        return "N/A"
      }
      const av = this.service.antivirus
      if (!av.isSupported) {
        return "NOT_SUPPORTED"
      }
      var result = (await av.isEnabled()) ? "Enabled" : "Disabled"
      const threats = await av.getThreatList()
      const filtered = threats
                        .filter(value => value.threatIndex == 'HIGHLY_DANGEROUS' || value.threatIndex == 'DANGEROUS' )
                        .map(value => {
                          return {
                            packageName: value.packageName,
                            threatIndex: value.threatIndex,
                            malwareDetectionName: value.malwareDetectionName
                          }
                        })
      AppLog(`Threats: ${JSON.stringify(filtered)}`)
      result += `, Threats = ${filtered.length} / ${threats.length}`
      return result  
    } catch (error) {
      return `Exception: ${JSON.stringify(error)}`
    }
  }

  populateModuleDetails() {
    this.populateRaspState().then((value) => this.setState({raspInfo: value}))
    this.populateAntivirusInfo().then((value) => this.setState({avState: value}))
  }

  get stateWithResult(): string {
    const s = this.state.moduleState
    if (s == 'READY') {
      const r = this.service.initializationResult
      if (r != undefined) {
        return `${s} / ${r}`
      }
    }
    return s
  }

  // State listener

  malwarelyticsStateChanged(state: MalwarelyticsState): void {
    AppLog(`Malwarelytics state ${state}`)
    this.setState({moduleState: state})
    this.populateModuleDetails()
  }

  // RASP listener

  debuggerDetected(detected: boolean): void {
    if (detected) {
      AppWarn(`Debugger is connected`)
    } else {
      AppLog(`Debugger is disconnected`)
    }
    this.populateModuleDetails()
  }
  repackagingDetected(info: RepackagingInfo): void {
    if (info == 'REPACKAGED_APP') {
      AppWarn(`Repackaging detected`)
    } else {
      AppLog(`Repackaging info ${info}`)
    }
    this.populateModuleDetails()
  }
  systemIntegrityCompromised(info: SystemIntegrityInfo): void {
    if (info.isRooted || info.isJailbroken) {
      AppWarn(`System integrity compromised: ${JSON.stringify(info)}`)
    } else {
      AppLog(`System integrity info: ${JSON.stringify(info)}`)
    }
    this.populateModuleDetails()
  }
  httpProxyDetected(info: HttpProxyInfo): void {
    if (info.isHttpProxyEnabled) {
      AppWarn(`HTTP proxy detected: ${JSON.stringify(info)}`)
    } else {
      AppLog(`HTTP proxy info: ${JSON.stringify(info)}`)
    }
    this.populateModuleDetails()
  }
  screenSharingDetected(info: ScreenSharingInfo): void {
    if (info.isScreenShared) {
      AppWarn(`Screen sharing detected: ${JSON.stringify(info)}`)
    } else {
      AppLog(`Screen sharing info: ${JSON.stringify(info)}`)
    }
    this.populateModuleDetails()
  }
  emulatorDetected(info: EmulatorInfo): void {
    if (info.isEmulator) {
      AppWarn(`Emulator detected: ${JSON.stringify(info)}`)
    } else {
      AppLog(`Emulator info: ${JSON.stringify(info)}`)
    }
    this.populateModuleDetails()
  }
  tapjackingDetected(info: TapjackingInfo): void {
    if (info.isTapjackingBlocked) {
      AppWarn(`Tapjacking detected: ${JSON.stringify(info)}`)
    } else {
      AppLog(`Tapjacking info: ${JSON.stringify(info)}`)
    }
    this.populateModuleDetails()
  }
  adbStatusDetected(adbStatus: boolean): void {
    if (adbStatus) {
      AppWarn(`ADB is connected`)
    }
    this.populateModuleDetails()
  }
  userScreenshotDetected(): void {
    AppWarn(`Used took screenshot`);
  }
  reverseEngineeringToolsDetected(): void {
    AppWarn(`Reverse engineering tools detected`)
    this.populateModuleDetails()
  }
  systemPasscodeConfigurationChanged(enabled: boolean): void {
    AppWarn(`System passcode is ${enabled ? "set" : "removed"}`)
    this.populateModuleDetails()
  }
  systemBiometryConfigurationChanged(enabled: boolean): void {
    AppWarn(`System biometry is ${enabled ? "set" : "removed"}`)
    this.populateModuleDetails()
  }  
  vpnDetected(active: boolean): void {
    if (active) {
      AppWarn(`VPN is active`)
    } else {
      AppLog(`VPN is not active`)
    }
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  box: {
    width: 60,
    height: 60,
    marginVertical: 20,
  },
  separator: {
    marginVertical: 8,
    borderBottomColor: '#737373',
    borderBottomWidth: StyleSheet.hairlineWidth,
  },
  progressTextDark: {
    textAlign: 'center',
    color: '#FFFFFF'
  },
  progressTextLight: {
    textAlign: 'center',
    color: '#000000'
  },
  fixToText: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  }
});

export default App;