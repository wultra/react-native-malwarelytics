//
// Copyright 2023 Wultra s.r.o.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.
//

import * as React from 'react';

import { StyleSheet, View, Text, Appearance, NativeEventSubscription, SafeAreaView, Button, Platform, SectionList } from 'react-native';
import { EmulatorInfo, HttpProxyInfo, Malwarelytics, MalwarelyticsError, MalwarelyticsRaspListener, MalwarelyticsState, MalwarelyticsStateListener, RepackagingInfo, ScreenSharingInfo, SystemIntegrityInfo, TapjackingInfo, ActiveCallInfo, AppPresenceInfo } from 'react-native-malwarelytics';
import { loadMalwarelyticsConfig } from './Config';

function AppLog(message: string) {
  console.log(`${Platform.OS}: ${message}`)
}
function AppErr(message: string) {
  console.error(`${Platform.OS}: ${message}`)
}
function AppWarn(message: string) {
  console.warn(`${Platform.OS}: ${message}`)
}

function ErrorToString(error: any): string {
  if (error instanceof MalwarelyticsError) {
    if (error.originalException) {
      return `{ MalwarelyticsError code: ${error.code}, ${error.message}, cause: ${JSON.stringify(error.originalException)} }`
    } else {
      return `{ MalwarelyticsError code: ${error.code}, ${error.message} }`
    }
  }
  if (error instanceof Error) {
    if (error.cause) {
      return `{ Error name: ${error.name}, ${error.message}, cause: ${error.cause} }`
    } else {
      return `{ Error name: ${error.name}, ${error.message} }`
    }
  }
  return `{ Failure: ${JSON.stringify(error)} }`
}

interface ModuleParameter {
  key: string
  value: string
}

type ModuleParameters = ModuleParameter[]

interface AppState {
  isDark: boolean
  moduleState: MalwarelyticsState
  moduleInfo: ModuleParameters
  raspInfo: ModuleParameters
  avSupported: boolean
  avState: ModuleParameters
}

class App extends React.Component<{}, AppState> implements MalwarelyticsStateListener, MalwarelyticsRaspListener {
  state = {
    isDark: Appearance.getColorScheme() === 'dark',
    moduleState: 'SHUTDOWN' as MalwarelyticsState,
    moduleInfo: [],
    raspInfo: [],
    avSupported: Malwarelytics.sharedInstance.antivirus.isSupported,
    avState: []
  }
  
  subscription?: NativeEventSubscription

  componentDidMount() {
    // Register for service's events
    this.service.rasp.setRaspListener(this)
    // This is optional, because your application typically don't need 
    // to listen to the state changes. We're using this only for 
    // the debugging purposes.
    this.service.setStateListener(this)
    // Update UI depending on actual state of module
    this.service.getState().then((state) => {
      AppLog(`Initial state is ${state}`)
      this.setState({ moduleState: state})
    })
    // Patch appearance
    this.subscription = Appearance.addChangeListener((_preferences) => {
      this.setState({isDark: Appearance.getColorScheme() === 'dark'})
    })
    this.populateModuleDetails()
  }

  componentWillUnmount() {
    this.subscription?.remove()
    this.service.removeStateListener()
    this.service.rasp.removeRaspListener()
  }

  service: Malwarelytics = Malwarelytics.sharedInstance

  // Initialization

  async malwarelyticsInit() {
    try {
      this.service.rasp.setRaspListener(this)
      if (await this.service.isInitialized()) {
        AppWarn('Malwarelytics is already initialized')
        return
      }
      AppLog("Going to initialize..")
      const result = await this.service.initialize(loadMalwarelyticsConfig())
      AppLog(`Module is now initialized with result ${result}`)
    } catch (error) {
      AppErr(`Exception while init': ${ErrorToString(error)}`)
    }
  }
  
  async malwarelyticsShutdown() {
    try {
      if (!await this.service.isInitialized()) {
        AppWarn('Malwarelytics is already off')
        return
      }
      AppLog("Going to shutdown...")
      await this.service.shutdown()
      this.service.rasp.removeRaspListener()
      AppLog("Module is now off")
    } catch (error) {
      AppErr(`Exception while shutdown: ${ErrorToString(error)}`)
    }
  }

  async triggerSmartProtection() {
    try {
      if (!await this.service.isInitialized()) {
        return
      }
      if (await this.service.antivirus.isSmartProtectionTriggered()) {
        AppLog('SmartProtection evaluation is alrady triggered.')
        return
      } else {
        AppLog('Triggering SmartProtection evaluation.')
      }
      const result = await this.service.antivirus.triggerSmartProtection(true)  
      AppLog(`Smarpt Protection result: ${JSON.stringify(result)}`)
    } catch (error) {
      AppErr(`Smart protection failed: ${ErrorToString(error)}`)
    }
  }

  async populateModuleInfo(): Promise<ModuleParameters> {
    const params = new Array<ModuleParameter>()
    try {
      const state = await this.service.getState()
      params.push({key: 'State', value: state})
      const initResult = this.service.initializationResult
      if (initResult != undefined) {
        params.push({key: 'Init Result', value: initResult})
      }
      if (state == 'READY') {
        const avUID = await this.service.getAvUserId()
        params.push({key: 'avUid', value: avUID != undefined ? avUID : "N/A"})
      }
    } catch (error) {
      params.push({key: 'ðŸ’£ Exception', value: ErrorToString(error)})
    }
    return params
  }

  async populateRaspState(): Promise<ModuleParameters> {
    const params = new Array<ModuleParameter>()
    try {
      if (!await this.service.isInitialized()) {
        params.push({key: 'State', value: 'Not Available'})
        return params
      }

      const rasp = this.service.rasp
      params.push({key: 'Debugger', value: `${await rasp.isDebuggerConnected()}`})
      const emulator = await rasp.isRunningInEmulator()
      params.push({key: 'Emulator', value: `${emulator}`})
      if (emulator) {
        params.push({key: 'Emulator Info', value: JSON.stringify(await rasp.getEmulatorInfo())})
      }
      params.push({key: 'Repackaging', value: await rasp.getRepackagingInfo()})
      params.push({key: 'HTTP Proxy', value: JSON.stringify(await rasp.getHttpProxyInfo())})
      params.push({key: 'Screen Sharing', value: JSON.stringify(await rasp.getScreenSharingInfo())})
      params.push({key: 'VPN', value: `${await rasp.isVpnActive()}`})
      params.push({key: 'On Call', value: `${await rasp.isOnCall()}`})
      
      if (Platform.OS == 'ios') {
        // iOS specific
        params.push({key: 'R-E-Tools', value: `${await rasp.isReverseEngineeringToolsPresent()}`})
        params.push({key: 'System Passcode', value: `${await rasp.isSystemPasscodeEnabled()}`})
        params.push({key: 'Biometry Enrolled', value: `${await rasp.isSystemBiometryEnabled()}`})
      } else {
        // Android specific
        params.push({key: 'Debugger info', value: JSON.stringify(await rasp.getDebuggerInfo())})
        params.push({key: 'Development mode', value: `${await rasp.isDeveloperOptionsEnabled()}`})
        params.push({key: 'Screen Lock', value: `${await rasp.isScreenLockEnabled()}`})
        params.push({key: 'Not Allowed Screen Reader', value: `${await rasp.isNotAllowedScreenReaderEnabled()}`})
        params.push({key: 'Play Protect', value: `${await rasp.isPlayProtectEnabled()}`})
        params.push({key: 'Biometry', value: JSON.stringify(await rasp.getBiometryInfo())})
        params.push({key: 'ADB', value: `${await rasp.getAdbStatus()}`})
        params.push({key: 'Tapjacking', value: JSON.stringify(await rasp.getTapjackingInfo())})
        params.push({key: 'Bad Tapjacking App', value: `${await rasp.isBadTapjackingCapableAppPresent()}`})
        params.push({key: 'Active Call', value: JSON.stringify(await rasp.getActiveCallInfo())})
        params.push({key: 'App Presence', value: JSON.stringify(await rasp.getAppPresenceInfo())})
      }
    } catch (error) {
      params.push({key: 'ðŸ’£ Exception', value: ErrorToString(error)})
    }
    return params
  }

  async populateAntivirusInfo(): Promise<ModuleParameters> {
    const params = new Array<ModuleParameter>()
    try {
      if (!await this.service.isInitialized()) {
        params.push({key: 'State', value: 'Not Available'})
        return params
      }
      const av = this.service.antivirus
      params.push({key: 'Supported', value: `${av.isSupported}`})
      if (!av.isSupported) {
        return params
      }
      const isEnabled = (await av.isEnabled())
      params.push({key: 'Enabled', value: `${isEnabled}`})
      if (isEnabled) {
        const threats = await av.getFilteredThreatList('DANGEROUS')
        if (threats.length > 0) {
          params.push({key: 'Threats', value: `${threats.length}`})
          threats.forEach((threat, index) => {
            var flagStr = ''
            if (threat.flags.length > 0) {
              flagStr = `\n${JSON.stringify(threat.flags)}`
            }
            params.push({key: ` #${index + 1}`, value: `${threat.packageName}\n${threat.threatIndex}${flagStr}`})
          })
        } else {
          params.push({key: 'Threats', value: `0`})
        }
      }
    } catch (error) {
      params.push({key: 'ðŸ’£ Exception', value: ErrorToString(error)})
    }
    return params
  }

  populateModuleDetails() {
    this.populateModuleInfo().then((value => this.setState({moduleInfo: value}) ))
    this.populateRaspState().then(value => this.setState({raspInfo: value}))
    this.populateAntivirusInfo().then(value => this.setState({avState: value}))
  }

  get stateWithResult(): string {
    const s = this.state.moduleState
    if (s == 'READY') {
      const r = this.service.initializationResult
      if (r != undefined) {
        return `${s} / ${r}`
      }
    }
    return s
  }

  // State listener

  malwarelyticsStateChanged(state: MalwarelyticsState): void {
    AppLog(`Malwarelytics state ${state}`)
    this.setState({moduleState: state})
    this.populateModuleDetails()
  }

  // RASP listener

  debuggerDetected(detected: boolean): void {
    if (detected) {
      AppLog(`Debugger is connected`)
    } else {
      AppLog(`Debugger is disconnected`)
    }
    this.populateModuleDetails()
  }
  repackagingDetected(info: RepackagingInfo): void {
    if (info == 'REPACKAGED_APP') {
      AppLog(`Repackaging detected`)
    } else {
      AppLog(`Repackaging info ${info}`)
    }
    this.populateModuleDetails()
  }
  systemIntegrityCompromised(info: SystemIntegrityInfo): void {
    if (info.isRooted || info.isJailbroken) {
      AppLog(`System integrity compromised: ${JSON.stringify(info)}`)
    } else {
      AppLog(`System integrity info: ${JSON.stringify(info)}`)
    }
    this.populateModuleDetails()
  }
  httpProxyDetected(info: HttpProxyInfo): void {
    if (info.isHttpProxyEnabled) {
      AppLog(`HTTP proxy detected: ${JSON.stringify(info)}`)
    } else {
      AppLog(`HTTP proxy info: ${JSON.stringify(info)}`)
    }
    this.populateModuleDetails()
  }
  screenSharingDetected(info: ScreenSharingInfo): void {
    if (info.isScreenShared) {
      AppLog(`Screen sharing detected: ${JSON.stringify(info)}`)
    } else {
      AppLog(`Screen sharing info: ${JSON.stringify(info)}`)
    }
    this.populateModuleDetails()
  }
  emulatorDetected(info: EmulatorInfo): void {
    if (info.isEmulator) {
      AppLog(`Emulator detected: ${JSON.stringify(info)}`)
    } else {
      AppLog(`Emulator info: ${JSON.stringify(info)}`)
    }
    this.populateModuleDetails()
  }
  tapjackingDetected(info: TapjackingInfo): void {
    if (info.isTapjackingBlocked) {
      AppLog(`Tapjacking detected: ${JSON.stringify(info)}`)
    } else {
      AppLog(`Tapjacking info: ${JSON.stringify(info)}`)
    }
    this.populateModuleDetails()
  }
  adbStatusDetected(adbStatus: boolean): void {
    AppLog(`ADB is ${adbStatus ? 'connected' : 'disconnected'}`)
    this.populateModuleDetails()
  }
  userScreenshotDetected(): void {
    AppLog(`Used took screenshot`);
  }
  reverseEngineeringToolsDetected(): void {
    AppWarn(`Reverse engineering tools detected`)
    this.populateModuleDetails()
  }
  systemPasscodeConfigurationChanged(enabled: boolean): void {
    AppWarn(`System passcode is ${enabled ? "set" : "removed"}`)
    this.populateModuleDetails()
  }
  systemBiometryConfigurationChanged(enabled: boolean): void {
    AppLog(`System biometry is ${enabled ? "set" : "removed"}`)
    this.populateModuleDetails()
  }  
  vpnDetected(active: boolean): void {
    AppLog(`VPN is ${active ? 'active' : 'inactive'}`)
    this.populateModuleDetails()
  }
  isOnCallChanged(isOnCall: boolean): void {
    AppLog(`Phone call is ${isOnCall ? 'active' : 'inactive'}`)
    this.populateModuleDetails()
  }
  activeCallDetected(info: ActiveCallInfo): void {
    AppLog(`Active call detected: ${JSON.stringify(info)}`)
    this.populateModuleDetails()
  }
  appPresenceChangeDetected(info: AppPresenceInfo): void {
    AppLog(`App presence detected: ${JSON.stringify(info)}`)
    this.populateModuleDetails()
  }

  // Render

  render(): React.ReactNode {
    const data = [
      {
        title: "Module", data: this.state.moduleInfo
      },
      {
        title: "RASP", data: this.state.raspInfo
      },
      {
        title: "Antivirus", data: this.state.avState
      }
    ]
    return (
      <SafeAreaView style={styles.container}>
        <SectionList 
              sections={data}
              renderItem={({ item }) => (
                <View style={styles.rowContainer}>
                  <View style={styles.itemKey}>
                      <Text style={styles.itemKeyText}>{item.key}</Text>
                  </View>
                  <View style={styles.itemValue}>
                      <Text style={styles.itemValueText}>{item.value}</Text>
                  </View>
                </View>
              )}
              renderSectionHeader={({section: {title}}) => (
                <Text style={styles.header}>{title}</Text>
              )}
              ItemSeparatorComponent={() => (
                <View style={styles.rowSeparator} />
              )}
          />
        {
          this.state.avSupported && this.state.moduleState == 'READY' ? 
            <Button title="SmartProtection" onPress={() => this.triggerSmartProtection() } /> :
            ""
        }
        {
          this.state.moduleState === "READY" ?
            <View style={styles.fixToText}>
              <Button title="Shutdown" onPress={() => this.malwarelyticsShutdown() } />
              <Button title="Refresh" onPress={() => this.populateModuleDetails() } />
            </View> : this.state.moduleState == "SHUTDOWN" ?
            <View style={styles.fixToText}>
              <Button title="Initialize" onPress={() => this.malwarelyticsInit() } />
            </View> :
            <View style={styles.fixToText}>
              <Button title="Please wait" />
            </View>
        }

      </SafeAreaView>
    )
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  rowContainer: {
    flexDirection: 'row' 
  },
  itemKey: {
    width: '35%'
  },
  itemKeyText: {
    padding: 2,
    fontSize: 12,
    fontWeight: 'bold',
    textAlign: 'left'
  },
  itemValue: {
    width: '65%'
  },
  itemValueText: {
    padding: 2,
    fontSize: 12,
    fontWeight: 'normal',
    textAlign: 'left'
  },
  rowSeparator: {
    backgroundColor: 'gray',
    height: 1 
  },
  header: {
    textAlign: 'center',
    fontSize: 14,
    padding: 8,
    fontWeight: 'bold',
    backgroundColor: '#ddd',
  },
  fixToText: {
    flexDirection: 'row',
  }
});

export default App;